<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Added mobile viewport -->
  <title>Dune Awakening Deep Desert Mapping</title>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #000;
    }
    h1 {
      color: #fff;
      font-size: 2.2em;
      letter-spacing: 0.03em;
      text-align: center;
    }    .main-flex {
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      gap: 32px;
      width: 100%;
      max-width: none;
      position: relative;
      padding-left: 20px;
    }
    
    .left-sidebar {
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 220px;
      max-width: 220px;
      flex-shrink: 0;
      align-items: center;
    }
    
    .right-sidebar {
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 220px;
      max-width: 220px;
      flex-shrink: 0;
      align-items: center;
    }
    
    .main-controls {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      margin: 0;
      min-width: 200px;
      max-width: 200px;
      width: 100%;
      position: static;
      top: unset;
      left: unset;
      z-index: 99;
    }
    
    .main-controls .pretty-btn {
      margin: 4px 0;
      min-width: 140px;
      width: 100%;
    }
    
    .grid-outer {
      flex: 1 1 0;
      min-width: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .grid-label-row,
    .grid-label-col {
      display: none !important;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      gap: 2px;
      width: 900px;
      height: 900px;
      background: #222;
      border-radius: 10px;
      box-shadow: 0 0 16px #000a;
    }
    @media (max-width: 1000px) {
      .grid-container {
        width: 98vw;
        height: 98vw;
        max-width: 98vw;
        max-height: 98vw;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }
    }
    .cell {
      border: 1.5px solid #222;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      background-color: transparent;
      font-size: 1.1em;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
      position: relative;
      overflow: hidden;
      touch-action: manipulation;
      width: 100%;
      height: 100%;
      min-width: 0;
      min-height: 0;
    }
    .cell:hover, .cell:active {
      background-color: rgba(255,255,255,0.1);
    }
    .cell-label {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 14px;
      color: #fff;
      opacity: 0.7;
      pointer-events: none;
      z-index: 2;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }    .cell-icons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 2px;
      align-items: center;
      justify-items: center;
      width: 100%;
      height: 100%;
      padding: 22px 4px 4px 4px;
      z-index: 1;
    }
    .cell-icon-container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      min-height: 24px;
    }
    .cell-icons img {
      width: 28px;
      height: 28px;
      background: rgba(34, 34, 34, 0.8);
      border-radius: 3px;
      border: 1px solid #555;
      pointer-events: none;
      user-select: none;
      object-fit: contain;
    }    .legend {
      align-self: stretch;
      color: #fff;
      background: rgba(30,30,30,0.85);
      padding: 8px 10px;
      border-radius: 10px;
      min-width: 0;
      max-width: none;
      width: 100%;
      font-size: 0.85em;
      position: static;
      box-sizing: border-box;
      transition: max-height 0.3s, padding 0.3s;
      overflow: hidden;
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      margin-top: 0;
    }
    .legend.collapsed {
      max-height: 38px;
      padding-bottom: 0;
    }
    .legend-toggle {
      cursor: pointer;
      color: #ffe066;
      font-size: 1.1em;
      font-weight: bold;
      background: none;
      border: none;
      outline: none;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-toggle:focus {
      outline: 2px solid #ffe066;
    }
    .controls {
      margin-top: 30px;
      display: block;
      justify-content: unset;
      gap: unset;
      flex-wrap: unset;
      width: auto;
    }
    .cell.unexplored::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(30,30,30,0.55);
      pointer-events: none;
      z-index: 2;
    }
    .cell.explored::after {
      display: none;
    }
    .explored-toggle {
      color: #ffe066 !important;
      text-shadow: 0 0 2px #222, 0 0 8px #ffe066;
    }
    .cell.unexplored .explored-toggle {
      color: #ffe066 !important;
      opacity: 0.7;
    }
    #useLocalTime {
      accent-color: #ffe066;
    }
    #timeModeLabel {
      color: #fff700;
      font-weight: bold;
    }    .side-controls {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-top: 0;
      align-items: stretch;
      margin-left: 0;
      width: 100%;
    }
    .time-toggle {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 4px;
      width: 100%;
    }
    .switch-label {
      display: flex;
      align-items: center;
      color: #ffe066;
      font-weight: bold;
      font-size: 1.05em;
      gap: 6px;
      min-width: 0;
      width: 100%;
      justify-content: space-between;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      margin: 0 2px;
      flex-shrink: 0;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #444;
      border-radius: 24px;
      transition: background 0.2s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: #ffe066;
      border-radius: 50%;
      transition: transform 0.2s;
      box-shadow: 0 1px 4px #2226;
    }
    .switch input:checked + .slider {
      background: #ffe066;
    }
    .switch input:checked + .slider:before {
      background: #444;
      transform: translateX(20px);
    }
    .pretty-btn {
      background: linear-gradient(90deg, #ffe066 0%, #ffd700 100%);
      color: #222;
      border: none;
      border-radius: 5px;
      padding: 4px 10px;
      min-width: 70px;
      min-height: 28px;
      font-size: 0.85em;
      font-weight: bold;
      letter-spacing: 0.03em;
      box-shadow: 0 2px 8px #2224;
      cursor: pointer;
      margin: 0 0 10px 0;
      transition: background 0.2s, color 0.2s, transform 0.1s;
      outline: none;
      display: inline-block;
      touch-action: manipulation;
    }
    .pretty-btn:hover, .pretty-btn:focus {
      background: linear-gradient(90deg, #fff6b0 0%, #ffe066 100%);
      color: #111;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 16px #ffe06655;
    }
    #stormTimer {
      text-align: left;
      width: auto;
      margin-left: 0;
      min-width: 140px;
      width: 100%;
    }
    
    /* Enhanced Timer Styling */
    .timer-container {
      background: rgba(42, 24, 16, 0.8);
      border: 2px solid #d4af37;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .timer-phases {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .timer-phase {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      border-left: 4px solid #666;
      transition: all 0.3s ease;
    }
    
    .timer-phase.active {
      border-left-color: #ffe066;
      background: rgba(255, 224, 102, 0.1);
      box-shadow: 0 0 8px rgba(255, 224, 102, 0.3);
    }
    
    .timer-phase.warning {
      border-left-color: #ff9800;
      background: rgba(255, 152, 0, 0.1);
    }
    
    .timer-phase.critical {
      border-left-color: #f44336;
      background: rgba(244, 67, 54, 0.1);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .phase-label {
      color: #ffe066;
      font-weight: bold;
      font-size: 0.9em;
    }
    
    .phase-time {
      color: #fff;
      font-family: 'Courier New', monospace;
      font-size: 1em;
    }
    
    .server-selector {
      margin-bottom: 16px;
    }
    
    .server-selector label {
      color: #ffe066;
      font-weight: bold;
      font-size: 1em;
      display: block;
      margin-bottom: 8px;
    }
    
    .server-selector select {
      width: 100%;
      padding: 8px 12px;
      background: rgba(42, 24, 16, 0.9);
      border: 2px solid #d4af37;
      border-radius: 8px;
      color: #ffe066;
      font-size: 0.95em;
      cursor: pointer;
      outline: none;
    }
    
    .server-selector select:focus {
      border-color: #ffe066;
      box-shadow: 0 0 8px rgba(255, 224, 102, 0.3);
    }
    
    .server-selector option {
      background: #2a1810;
      color: #ffe066;
    }    /* --- Mobile Mode --- */
    @media (max-width: 1000px) {      .main-flex {
        flex-direction: column;
        align-items: center;
        gap: 32px;
        max-width: 100vw;
        padding-left: 0;
      }
        .left-sidebar {
        min-width: 98vw;
        max-width: 98vw;
        width: 98vw;
        order: 2;
        gap: 20px;
        padding: 0 1vw;
      }
      
      .grid-outer {
        margin-left: 0;
        margin-right: 0;
        order: 1;
      }
      
      .right-sidebar {
        min-width: 98vw;
        max-width: 98vw;
        width: 98vw;
        order: 3;
        gap: 20px;
        padding: 0 1vw;
      }
      
      .main-controls {
        flex-direction: column;
        gap: 8px;
        margin: 16px auto;
        width: 100%;
        max-width: 100%;
        margin-right: 0;
        align-items: center;
      }
      
      .main-controls .pretty-btn {
        width: 100%;
        min-width: unset;
        margin: 2px 0;
      }
      
      .side-controls {
        width: 100%;
        max-width: 100%;
        margin-left: 0;
        margin: 16px auto;
      }        .legend {
        margin: 0 auto;
        min-width: 0;
        max-width: 98vw;
        width: 98vw;
        margin-top: 16px;
        font-size: 12px;
        padding: 8px 4px 12px 4px;
      }
      .grid-container {
        width: 98vw;
        height: 98vw;
        max-width: 98vw;
        max-height: 98vw;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }
      .cell {
        font-size: 10px;
      }
      .cell-label {
        font-size: 11px;
      }      .cell-icons img {
        width: 18px;
        height: 18px;
      }
      .cell-icons {
        padding: 18px 2px 2px 2px;
        gap: 1px;
      }      .cell-icon-container {
        min-height: 18px;
      }
      .legend.collapsed {
        max-height: 38px;
        padding-bottom: 0;
      }      .legend-item img {
        width: 24px;
        height: 24px;
      }
      .legend-item {
        padding: 4px 2px;
        gap: 6px;
        margin-bottom: 2px;
      }
      .legend-item span {
        font-size: 11px;
      }      .pretty-btn {
        min-width: 120px;
        padding: 12px 16px;
        font-size: 1em;
        min-height: 44px; /* Better touch target for mobile */
      }
    }
    [aria-label][tabindex] {
      outline: none;
    }
    [aria-label][tabindex]:focus {
      outline: 2px solid #ffe066;
    }    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 2px 0;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-bottom: 4px;
      min-height: 40px;
      width: 100%;
      box-sizing: border-box;
      font-size: 0.85em;
      min-width: 80px;
    }
    
    .legend-item:hover {
      background-color: rgba(255, 224, 102, 0.1);
    }
    
    .legend-item:focus {
      outline: 2px solid #ffe066;
      background-color: rgba(255, 224, 102, 0.1);
    }

    .legend-item img {
      width: 32px;
      height: 32px;
      flex-shrink: 0;
      border-radius: 3px;
      background: rgba(34, 34, 34, 0.8);
      border: 1px solid #555;
    }
    
    .legend-item span {
      color: #fff;
      font-size: 13px;
      font-weight: normal;
      flex: 1;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      line-height: 1.3;
      min-width: 0;
    }/* Help Modal Styling - Dune Filmbook Style */
    #helpModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      align-items: center;
      justify-content: center;
      z-index: 1001;
      pointer-events: auto;
    }
    
    .help-content {
      background: linear-gradient(135deg, #2a1810 0%, #1a0f08 100%);
      border: 3px solid #d4af37;
      border-radius: 15px;
      padding: 30px;
      max-width: 600px;
      width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      position: relative;
      font-family: 'Courier New', monospace;
    }
    
    .help-content::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 20%, rgba(212, 175, 55, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(212, 175, 55, 0.1) 0%, transparent 50%);
      border-radius: 12px;
      pointer-events: none;
    }
    
    .help-title {
      color: #d4af37;
      font-size: 1.8em;
      font-weight: bold;
      text-align: center;
      margin: 0 0 20px 0;
      text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
      letter-spacing: 2px;
      text-transform: uppercase;
      position: relative;
      z-index: 1;
    }
    
    .help-section {
      margin-bottom: 25px;
      position: relative;
      z-index: 1;
    }
    
    .help-section h3 {
      color: #ffe066;
      font-size: 1.3em;
      margin: 0 0 12px 0;
      border-bottom: 2px solid rgba(212, 175, 55, 0.3);
      padding-bottom: 5px;
      letter-spacing: 1px;
    }
    
    .help-shortcut {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
      color: #e6d4a3;
    }
    
    .help-shortcut:last-child {
      border-bottom: none;
    }
    
    .help-key {
      background: linear-gradient(145deg, #3a2415, #2a1810);
      border: 2px solid #d4af37;
      padding: 4px 8px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      color: #d4af37;
      text-shadow: 0 0 5px rgba(212, 175, 55, 0.3);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .help-description {
      color: #c9b995;
      flex: 1;
      margin-left: 15px;
    }
    
    .help-close {
      background: linear-gradient(145deg, #d4af37, #b8941f);
      color: #1a0f08;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      margin: 20px auto 0;
      display: block;
      transition: all 0.3s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      position: relative;
      z-index: 1;
    }
      .help-close:hover {
      background: linear-gradient(145deg, #e6c755, #d4af37);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    /* Mobile responsiveness for help modal */
    @media (max-width: 1000px) {
      .help-content {
        width: 95vw;
        max-width: none;
        margin: 10px;
        padding: 20px;
      }    }

    /* Icon Picker Modal Styling */
    #iconPickerModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.5);
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .icon-picker-content {
      background: rgba(40, 40, 40, 0.95);
      border: 2px solid #ffe066;
      padding: 24px;
      border-radius: 12px;
      max-width: 600px;
      width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      position: relative;
    }
    
    .icon-picker-content h3 {
      color: #ffe066;
      margin: 0 0 16px 0;
      font-size: 1.3em;
      text-align: center;
    }
    
    .icon-picker-buttons {
      margin-top: 16px;
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .icon-picker-btn {
      background: linear-gradient(90deg, #ffe066 0%, #ffd700 100%);
      color: #222;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 100px;
    }
    
    .icon-picker-btn:hover {
      background: linear-gradient(90deg, #fff6b0 0%, #ffe066 100%);
      transform: translateY(-1px);
    }
    
    #iconPickerGrid img {
      width: 32px;
      height: 32px;
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 6px;
      background: rgba(34, 34, 34, 0.8);
      padding: 2px;
      transition: all 0.2s;
    }
    
    #iconPickerGrid img:hover {
      background: rgba(255, 224, 102, 0.2);
      border-color: #ffe066;
      transform: scale(1.1);
    }

    .icon-picker-btn.cancel {
      background: linear-gradient(90deg, #666 0%, #888 100%);
      color: #fff;
    }
    
    .icon-picker-btn.cancel:hover {
      background: linear-gradient(90deg, #777 0%, #999 100%);
    }

    .side-controls {
      margin-top: 24px;
    }

    .legend-section-header {
      font-weight: bold;
      font-size: 1em;
      margin-bottom: 6px;
      margin-top: 8px;
      color: #ffe066;
      letter-spacing: 0.5px;
      text-align: left;
    }

    .legend.legend-split {
      display: flex;
      flex-direction: column;
      gap: 18px;
      background: none;
      box-shadow: none;
      padding: 0;
    }    .legend-box {
      background: rgba(30,30,30,0.92);
      border-radius: 12px;
      box-shadow: 0 3px 15px rgba(0,0,0,0.3);
      padding: 8px 10px;
      margin: 0 0 16px 0;
      min-width: 120px;
      max-width: 500px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      border: 3px solid transparent;
      transition: all 0.3s ease;
      overflow: hidden;
      box-sizing: border-box;
    }
    
    .legend-box-resources {
      border-color: #ffe066 !important;
      box-shadow: 0 3px 15px rgba(0,0,0,0.3), 0 0 12px rgba(255, 224, 102, 0.3) !important;
    }
    
    .legend-box-houses {
      border-color: #a259e6 !important;
      box-shadow: 0 3px 15px rgba(0,0,0,0.3), 0 0 12px rgba(162, 89, 230, 0.3) !important;
    }
    
    .legend-box-houses .legend-section-header {
      color: #a259e6;
    }
    .legend.legend-row {
      display: block;
      background: none;
      box-shadow: none;
      padding: 0;
    }    .legend-row-inner {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
      justify-content: flex-start;
      width: 100%;
      max-width: none;
    }.legend-houses-grid {
      display: flex;
      flex-direction: row;
      gap: 4px;
      width: 100%;
    }
    .legend-houses-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1 1 0;
      min-width: 0;
      overflow: hidden;
    }    @media (max-width: 1200px) {
      .legend-row-inner {
        flex-direction: column;
        gap: 8px;
        align-items: center;
      }
      .legend-box {
        width: 90vw !important;
        max-width: 90vw !important;
        min-width: 120px !important;
      }
      .legend-houses-grid {
        flex-direction: column;
        gap: 4px;
      }
      .legend-houses-col {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 4px;
      }      .legend-item {
        min-width: 80px;
        flex: 0 0 auto;
      }
    }
    .pretty-btn, .main-controls button, .side-controls button {
      font-size: 0.6em;
      padding: 2px 5px;
      min-width: 35px;
      min-height: 14px;
      border-radius: 3px;
    }
    #legend-panel {
      width: 220px;
      min-width: 180px;
      background: rgba(40, 30, 15, 0.98);
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 2px 8px #000a;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      height: fit-content;
    }
    /* If legendPanel is used as an id, ensure the HTML matches this id. */
    #legendPanel {
      width: 220px;
      min-width: 180px;
      background: rgba(40, 30, 15, 0.98);
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 2px 8px #000a;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      height: fit-content;
      margin-top: 24px;
      margin-bottom: 24px;
      align-self: center;
    }
    .legend-box {
      background: none;
      box-shadow: none;
      border-radius: 0;
      padding: 0;
      min-width: unset;
      max-width: unset;
    }
  </style>
</head>
<body>
  <div style="display:flex; align-items:center; justify-content:center; margin-bottom:10px;">
    <img src="arrakis.png" alt="Arrakis Icon" style="width:54px; height:54px; margin-right:16px; vertical-align:middle;">
    <h1 style="color:#fff; margin:0;">Dune Awakening Deep Desert Mapping</h1>
  </div>  
  <div class="timer-container">
      <div class="server-selector" style="max-width: 180px; margin-bottom: 8px;">
        <label for="serverLocation" style="font-size:0.95em; margin-bottom:4px;">Server Location:</label>
        <select id="serverLocation" style="font-size:0.95em; padding:4px 8px;">
          <option value="US East">US East (EST/EDT)</option>
          <option value="US Central">US Central (CST/CDT)</option>
          <option value="US West">US West (PST/PDT)</option>
          <option value="South America">US West (PST/PDT)</option>
          <option value="Europe">Central Europe (CET/CEST)</option>
          <option value="Asia">Asia (CST)</option>
          <option value="Australia">Australia East (AEST/AEDT)</option>
        </select>
      </div>
      <div class="timer-phases" id="timerPhases">
        <div class="timer-phase" id="buildupPhase">
          <span class="phase-label">⚡ Storm Buildup:</span>
          <span class="phase-time" id="buildupTime">calculating...</span>
        </div>
        <div class="timer-phase" id="hitPhase">
          <span class="phase-label">🌪️ Storm Hits:</span>
          <span class="phase-time" id="hitTime">calculating...</span>
        </div>
      </div>
    </div>  <div class="main-flex">
    <div class="left-sidebar">
      <div class="legend" id="legendPanel"></div>
    </div>
    <div class="grid-outer">
      <div style="display:flex;">
        <div class="grid-container" id="gridContainer" role="grid" aria-label="Map grid"></div>
      </div>
    </div>
    <div class="right-sidebar">
      <div class="main-controls">
        <button id="exploreAllButton" class="pretty-btn">Explore All</button>
        <button id="undoButton" class="pretty-btn">Undo</button>
        <button id="redoButton" class="pretty-btn">Redo</button>
        <button id="clearButton" class="pretty-btn">Clear Map</button>
      </div>
      <div class="side-controls">
        <div class="time-toggle">
          <label class="switch-label">
            <span id="timeModeLabel" style="margin-right:10px;">Local</span>
            <label class="switch">
              <input type="checkbox" id="useLocalTime" checked>
              <span class="slider"></span>
            </label>
            <span id="utcModeLabel" style="margin-left:10px;">UTC</span>
          </label>
        </div>
      </div>
    </div>
  </div><!-- Icon Picker Modal -->
  <div id="iconPickerModal">
    <div class="icon-picker-content">
      <h3>Select an Icon</h3>
      <div id="iconPickerGrid" style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;"></div>
      <div class="icon-picker-buttons">
        <button id="confirmSelectionButton" class="icon-picker-btn" type="button">Confirm</button>
        <button class="icon-picker-btn cancel" onclick="closeIconPicker()">Cancel</button>
      </div>
      <div id="iconPickerFeedback" style="display:none; position:absolute; top:10px; right:20px; background:#ffe066; color:#222; font-weight:bold; padding:6px 18px; border-radius:8px; box-shadow:0 2px 8px #2224; z-index:10;">Icon placed!</div>
    </div>
  </div>

  <!-- FWB Disclaimer and Logo -->
  <div style="width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;margin-top:32px;margin-bottom:18px;">
    <img src="fwb.png" alt="Fremen with Benefits Logo" style="height:44px;width:auto;margin-bottom:8px;filter:drop-shadow(0 2px 8px #2228);">
    <div style="color:#ffe066;font-size:1.08em;text-align:center;max-width:600px;text-shadow:0 1px 4px #222;">
  <script>
    let useLocalTime = true;
    const gridContainer = document.getElementById('gridContainer');
    let gridData = [];
    let exploredGrid = [];
    let undoStack = [];
    let redoStack = [];
    let selectedCells = new Set();
    let isSelecting = false;

    const resourcePoiIconNames = [
      'Authorized Base', 'Cave', 'Home Base', 'POI', 'Shipwreck', 'Shipwreck (x2)', 'Spice', 'Stravidium', 'Testing Station', 'Titanium'
    ];
    const resourcePoiIcons = [
      'AuthorizedBase.svg', 'Cave.svg', 'HomeBase.svg', 'Poi.svg', 'Shipwreck.svg', 'ShipwreckX2.svg', 'Spice.svg', 'Stravidium.svg', 'TestingStation.svg', 'Titanium.svg'
    ];

    const houseIconNames = [
      'House Alexin', 'House Argpsaz', 'House Dyvetz', 'House Ecaz', 'House Hagal', 'House Hurata', 'House Imota',
      'House Kenola', 'House Lindaren', 'House Maros', 'House Mikarrol', 'House Moritani', 'House Mutelli',
      'House Novebruns', 'House Richese', 'House Sor', 'House Spinnette', 'House Taligari', 'House Thorvald',
      'House Tseida', 'House Varota', 'House Vernius', 'House Wallach', 'House Wayku', 'House Wydras'
    ];
    const houseIcons = [
      'House_Alexin.svg', 'House_Argpsaz.svg', 'House_Dyvetz.svg', 'House_Ecaz.svg', 'House_Hagal.svg', 'House_Hurata.svg', 'House_Imota.svg',
      'House_Kenola.svg', 'House_Lindaren.svg', 'House_Maros.svg', 'House_Mikarrol.svg', 'House_Moritani.svg', 'House_Mutelli.svg',
      'House_Novebruns.svg', 'House_Richese.svg', 'House_Sor.svg', 'House_Spinnette.svg', 'House_Taligari.svg', 'House_Thorvald.svg',
      'House_Tseida.svg', 'House_Varota.svg', 'House_Vernius.svg', 'House_Wallach.svg', 'House_Wayku.svg', 'House_Wydras.svg'
    ];

    const iconPath = "Icons/";
    let currentCell = null;

    // Add debounce utility for performance
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Add throttle utility for high-frequency events
    function throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    }

    // Enhanced image loading with fallback and retry mechanism
    function loadImageWithFallback(src, fallbackSrc = null, retries = 2) {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        
        function attemptLoad(imageSrc) {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => {
            attempts++;
            if (attempts < retries && fallbackSrc) {
              console.warn(`Failed to load ${imageSrc}, trying fallback...`);
              attemptLoad(fallbackSrc);
            } else if (attempts < retries) {
              console.warn(`Failed to load ${imageSrc}, retrying... (${attempts}/${retries})`);
              setTimeout(() => attemptLoad(imageSrc), 1000);
            } else {
              console.error(`Failed to load image after ${retries} attempts: ${imageSrc}`);
              reject(new Error(`Image loading failed: ${imageSrc}`));
            }
          };
          img.src = imageSrc;
        }
        
        attemptLoad(src);
      });
    }

    // Improved renderLegend with error handling
    function renderLegend() {
      const legend = document.getElementById('legendPanel');
      legend.innerHTML = '';
      legend.className = 'legend legend-split legend-row';

      // Resources & POIs box
      const resourcesBox = document.createElement('div');
      resourcesBox.className = 'legend-box legend-box-resources';
      const resourcesHeader = document.createElement('div');
      resourcesHeader.className = 'legend-section-header';
      resourcesHeader.textContent = 'Resources & POIs';
      resourcesBox.appendChild(resourcesHeader);
      resourcePoiIcons.forEach((icon, idx) => {
        const div = document.createElement('div');
        div.className = 'legend-item';
        div.setAttribute('draggable', 'true');
        div.setAttribute('data-icon', icon);
        div.setAttribute('tabindex', '0');
        div.setAttribute('aria-label', resourcePoiIconNames[idx] + ' (drag to grid or click to select)');
        div.title = 'Drag to grid or click to select';
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = resourcePoiIconNames[idx];
        img.title = resourcePoiIconNames[idx];
        const span = document.createElement('span');
        span.textContent = resourcePoiIconNames[idx];
        div.appendChild(img);
        div.appendChild(span);
        resourcesBox.appendChild(div);
        div.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', this.getAttribute('data-icon'));
        });
        div.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
          }
        });
      });

      // Houses box with 2 columns
      const housesBox = document.createElement('div');
      housesBox.className = 'legend-box legend-box-houses';
      const housesHeader = document.createElement('div');
      housesHeader.className = 'legend-section-header';
      housesHeader.textContent = 'Houses';
      housesBox.appendChild(housesHeader);

      // Create a container for the two columns
      const housesGrid = document.createElement('div');
      housesGrid.className = 'legend-houses-grid';
      // Split houses into two columns
      const half = Math.ceil(houseIcons.length / 2);
      const leftHouses = houseIcons.slice(0, half);
      const rightHouses = houseIcons.slice(half);
      const leftNames = houseIconNames.slice(0, half);
      const rightNames = houseIconNames.slice(half);

      // Create columns
      const col1 = document.createElement('div');
      col1.className = 'legend-houses-col';
      leftHouses.forEach((icon, idx) => {
        const div = document.createElement('div');
        div.className = 'legend-item';
        div.setAttribute('draggable', 'true');
        div.setAttribute('data-icon', icon);
        div.setAttribute('tabindex', '0');
        div.setAttribute('aria-label', leftNames[idx] + ' (drag to grid or click to select)');
        div.title = 'Drag to grid or click to select';
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = leftNames[idx];
        img.title = leftNames[idx];
        const span = document.createElement('span');
        span.textContent = leftNames[idx];
        div.appendChild(img);
        div.appendChild(span);
        col1.appendChild(div);
        div.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', this.getAttribute('data-icon'));
        });
        div.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
          }
        });
      });
      const col2 = document.createElement('div');
      col2.className = 'legend-houses-col';
      rightHouses.forEach((icon, idx) => {
        const div = document.createElement('div');
        div.className = 'legend-item';
        div.setAttribute('draggable', 'true');
        div.setAttribute('data-icon', icon);
        div.setAttribute('tabindex', '0');
        div.setAttribute('aria-label', rightNames[idx] + ' (drag to grid or click to select)');
        div.title = 'Drag to grid or click to select';
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = rightNames[idx];
        img.title = rightNames[idx];
        const span = document.createElement('span');
        span.textContent = rightNames[idx];
        div.appendChild(img);
        div.appendChild(span);
        col2.appendChild(div);
        div.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', this.getAttribute('data-icon'));
        });
        div.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
          }
        });
      });
      housesGrid.appendChild(col1);
      housesGrid.appendChild(col2);
      housesBox.appendChild(housesGrid);

      // Add both boxes to the legend, side by side
      const legendRow = document.createElement('div');
      legendRow.className = 'legend-row-inner';
      legendRow.appendChild(resourcesBox);
      legendRow.appendChild(housesBox);
      legend.appendChild(legendRow);
    }

    // Debounced auto-save for better performance
    const debouncedAutoSave = debounce(autoSaveMap, 2000);

    // Throttled resize handler for better performance
    const throttledResize = throttle(function() {
      // Re-calculate grid dimensions on resize if needed
      rerenderAllCells();
    }, 250);

    // Memory management: Clear unused undo states periodically
    function cleanupMemory() {
      if (undoStack.length > 50) {
        undoStack.splice(0, undoStack.length - 50);
      }
      if (redoStack.length > 50) {
        redoStack.splice(0, redoStack.length - 50);
      }
    }

    function pushUndo() {
      try {
        undoStack.push({
          gridData: JSON.parse(JSON.stringify(gridData)),
          exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
          selectedCells: Array.from(selectedCells)
        });
        if (undoStack.length > 100) undoStack.shift();
        redoStack = [];
      } catch (error) {
        console.error('Failed to create undo state:', error);
      }
    }

    function undo() {
      if (undoStack.length === 0) return;
      redoStack.push({
        gridData: JSON.parse(JSON.stringify(gridData)),
        exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
        selectedCells: Array.from(selectedCells)
      });
      const prev = undoStack.pop();
      gridData = prev.gridData;
      exploredGrid = prev.exploredGrid;
      selectedCells = new Set(prev.selectedCells);
      rerenderAllCells();
      renderSelection();
    }

    function redo() {
      if (redoStack.length === 0) return;
      undoStack.push({
        gridData: JSON.parse(JSON.stringify(gridData)),
        exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
        selectedCells: Array.from(selectedCells)
      });
      const next = redoStack.pop();
      gridData = next.gridData;
      exploredGrid = next.exploredGrid;
      selectedCells = new Set(next.selectedCells);
      rerenderAllCells();
      renderSelection();
    }

    function cellKey(row, col) {
      return row + "," + col;
    }

    function initializeGrid() {
      gridContainer.innerHTML = "";
      gridData = [];
      exploredGrid = [];
      for (let row = 8; row >= 0; row--) {
        gridData[row] = [];
        exploredGrid[row] = [];
        for (let col = 0; col < 9; col++) {
          gridData[row][col] = [];
          exploredGrid[row][col] = false;
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-row', row);
          cell.setAttribute('data-col', col);
          cell.setAttribute('tabindex', '0');
          cell.setAttribute('aria-label', `Grid cell ${String.fromCharCode(65+row)}${col+1}`);
          cell.title = `Grid cell ${String.fromCharCode(65+row)}${col+1}`;
          cell.innerHTML = "";
          cell.addEventListener('click', handleCellClick);
          cell.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleCellClick({currentTarget: cell});
            }
          });
          gridContainer.appendChild(cell);
        }
      }
      makeCellsDroppable();
    }

    function handleCellClick(event) {
      const cell = event.currentTarget;
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      if (event.shiftKey) {
        // Multi-select
        const key = cellKey(row, col);
        if (selectedCells.has(key)) {
          selectedCells.delete(key);
        } else {
          selectedCells.add(key);
        }
        renderSelection();
        return;
      }
      if (selectedCells.size > 1) {
        // Batch edit: open icon picker for all selected
        currentCell = null;
        document.getElementById('iconPickerModal').style.display = 'flex';
      } else {
        currentCell = cell;
        document.getElementById('iconPickerModal').style.display = 'flex';
      }
    }

    function renderSelection() {
      document.querySelectorAll('.cell').forEach(cell => {
        const row = cell.getAttribute('data-row');
        const col = cell.getAttribute('data-col');
        const key = cellKey(row, col);
        if (selectedCells.has(key)) {
          cell.style.outline = '3px solid #ffe066';
          cell.style.boxShadow = '0 0 8px #ffe066cc';
        } else {
          cell.style.outline = '';
          cell.style.boxShadow = '';
        }
      });
    }

    function clearSelection() {
      selectedCells.clear();
      renderSelection();
    }

    function populateIconPicker() {
      const grid = document.getElementById('iconPickerGrid');
      grid.innerHTML = "";
      let selectedIcon = null;

      // Determine which icons are present in the current cell or all selected cells
      let presentIcons = new Set();
      if (selectedCells.size > 1) {
        // Multi-cell: collect all icons present in any selected cell
        selectedCells.forEach(key => {
          const [row, col] = key.split(',');
          gridData[row][col].forEach(icon => presentIcons.add(icon));
        });
      } else if (currentCell) {
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        gridData[row][col].forEach(icon => presentIcons.add(icon));
      }

      [...resourcePoiIcons, ...houseIcons].forEach(icon => {
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = icon;
        img.style.width = "48px";
        img.style.height = "48px";
        img.style.cursor = "pointer";
        img.style.border = presentIcons.has(icon) ? "2.5px solid #a259e6" : "2px solid transparent";
        img.style.borderRadius = "6px";
        img.title = icon.replace('.png','').replace('Icon','');
        img.onclick = () => {
          // Remove border from all icons
          Array.from(grid.children).forEach(child => {
            // Only remove border if not present in the cell(s)
            if (!presentIcons.has(child.alt)) {
              child.style.border = "2px solid transparent";
            }
          });
          img.style.border = "2.5px solid #a259e6";
          selectedIcon = icon;
          selectIcon(icon);
        };
        grid.appendChild(img);
      });
    }    // Batch icon selection for multi-cell
    function selectIcon(icon) {
      let placed = false;
      if (selectedCells.size > 1) {
        pushUndo();
        selectedCells.forEach(key => {
          const [row, col] = key.split(',');
          const idx = gridData[row][col].indexOf(icon);
          if (idx === -1) {
            gridData[row][col].push(icon);
            placed = true;
          } else {
            gridData[row][col].splice(idx, 1);
            placed = true;
          }
        });
        rerenderAllCells();
        renderSelection();
      } else if (currentCell) {
        pushUndo();
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        const idx = gridData[row][col].indexOf(icon);
        if (idx === -1) {
          gridData[row][col].push(icon);
          placed = true;
        } else {
          gridData[row][col].splice(idx, 1);
          placed = true;
        }
        renderCellIcons(currentCell, gridData[row][col]);
      }
      if (placed) {
        showIconPickerFeedback();
      }
    }

    function showIconPickerFeedback() {
      const feedback = document.getElementById('iconPickerFeedback');
      if (!feedback) return;
      feedback.textContent = 'Icon placed!';
      feedback.style.display = 'block';
      feedback.style.opacity = '1';
      setTimeout(() => {
        feedback.style.transition = 'opacity 0.5s';
        feedback.style.opacity = '0';
        setTimeout(() => {
          feedback.style.display = 'none';
          feedback.style.transition = '';
        }, 500);
      }, 600);
    }

    function renderCellIcons(cell, icons) {
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      const label = String.fromCharCode(65 + parseInt(row)) + (parseInt(col) + 1);

      if (icons.length > 0 && !exploredGrid[row][col]) {
        exploredGrid[row][col] = true;
      }

      const explored = exploredGrid[row][col];
      let checkHtml = explored
        ? `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark unexplored">&#x2714;</span>`
        : `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark explored">&#x25A2;</span>`;

      let exploredClass = explored ? "explored" : "unexplored";      // Build the cell content safely
      const wrapper = document.createElement('div');
      wrapper.innerHTML = `<span class="cell-label"></span>
        <div class="cell-icons"></div>${checkHtml}`;

      // Set label safely
      wrapper.querySelector('.cell-label').textContent = label;

      // Add icons safely with proper grid layout
      const iconsGrid = wrapper.querySelector('.cell-icons');
      for (let i = 0; i < 9; i++) {
        const iconContainer = document.createElement('div');
        iconContainer.className = 'cell-icon-container';
        
        if (icons[i]) {
          const img = document.createElement('img');
          img.src = iconPath + icons[i];
          img.alt = resourcePoiIconNames[resourcePoiIcons.indexOf(icons[i])] || houseIconNames[houseIcons.indexOf(icons[i])] || "";
          img.draggable = false;
          img.title = resourcePoiIconNames[resourcePoiIcons.indexOf(icons[i])] || houseIconNames[houseIcons.indexOf(icons[i])] || "";
          iconContainer.appendChild(img);
        }
        iconsGrid.appendChild(iconContainer);
      }

      // Replace cell content
      cell.innerHTML = '';
      Array.from(wrapper.childNodes).forEach(n => cell.appendChild(n));
      cell.classList.remove("explored", "unexplored");
      cell.classList.add(exploredClass);

      const toggle = cell.querySelector('.explored-toggle');
      if (toggle) {
        toggle.onclick = (e) => {
          e.stopPropagation();
          if (gridData[row][col].length === 0) {
            exploredGrid[row][col] = !exploredGrid[row][col];
            renderCellIcons(cell, icons);
          }
        };
        toggle.style.opacity = explored ? "1" : "0.5";
      }
      onMapChange();
    }

    function closeIconPicker() {
      document.getElementById('iconPickerModal').style.display = 'none';
      currentCell = null;
    }

    function clearMap() {
      if (confirm("This will clear all map data. Are you sure you want to continue?")) {
        try {
          pushUndo(); // Allow undoing clear operation
          initializeGrid();
          rerenderAllCells();
          onMapChange();
          showNotification('Map cleared successfully', 'success');
        } catch (error) {
          console.error('Clear failed:', error);
          showNotification('Failed to clear map', 'error');
        }
      }
    }

    function makeCellsDroppable() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.addEventListener('dragover', function (e) {
          e.preventDefault();
        });
        cell.addEventListener('drop', function (e) {
          e.preventDefault();
          const icon = e.dataTransfer.getData('text/plain');
          const row = this.getAttribute('data-row');
          const col = this.getAttribute('data-col');
          if (icon && gridData[row][col].indexOf(icon) === -1) {
            gridData[row][col].push(icon);
            renderCellIcons(this, gridData[row][col]);
          }
        });
      });
    }

    function rerenderAllCells() {
      const cells = document.querySelectorAll('.cell');
      let idx = 0;
      for (let row = 8; row >= 0; row--) {
        for (let col = 0; col < 9; col++) {
          renderCellIcons(cells[idx++], gridData[row][col]);
        }
      }
      makeCellsDroppable();
    }

    document.getElementById('confirmSelectionButton').onclick = function() {
      closeIconPicker();
    };

    function exploreAllCells() {
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          exploredGrid[row][col] = true;
        }
      }
      rerenderAllCells();
      onMapChange();
    }    // Enhanced Coriolis Storm Timer with fixed phases
    let selectedServerTimezone = 'UTC';
    
    function updateStormTimer() {
      const buildupTimeEl = document.getElementById('buildupTime');
      const hitTimeEl = document.getElementById('hitTime');
      const buildupPhase = document.getElementById('buildupPhase');
      const hitPhase = document.getElementById('hitPhase');
      const now = new Date();
      const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);

      // Storm Buildup: Monday 05:00 UTC (Europe)
      let nextBuildup = new Date(Date.UTC(utcNow.getUTCFullYear(), utcNow.getUTCMonth(), utcNow.getUTCDate(), 5, 0, 0, 0));
      // Storm Hits: Wednesday 04:00 UTC (Europe)
      let nextStorm = new Date(Date.UTC(utcNow.getUTCFullYear(), utcNow.getUTCMonth(), utcNow.getUTCDate(), 4, 0, 0, 0));
      const day = utcNow.getUTCDay();

      // Monday = 1, Wednesday = 3
      // Calculate next Monday 05:00 UTC
      if (day > 1 || (day === 1 && utcNow.getUTCHours() >= 5)) {
        nextBuildup.setUTCDate(nextBuildup.getUTCDate() + ((8 - day) % 7));
      } else if (day < 1 || (day === 1 && utcNow.getUTCHours() < 5)) {
        nextBuildup.setUTCDate(nextBuildup.getUTCDate() + ((1 - day + 7) % 7));
      }
      // Calculate next Wednesday 04:00 UTC
      if (day > 3 || (day === 3 && utcNow.getUTCHours() >= 4)) {
        nextStorm.setUTCDate(nextStorm.getUTCDate() + ((10 - day) % 7));
      } else if (day < 3 || (day === 3 && utcNow.getUTCHours() < 4)) {
        nextStorm.setUTCDate(nextStorm.getUTCDate() + ((3 - day + 7) % 7));
      }

      // Calculate time differences
      const buildupDiff = nextBuildup.getTime() - utcNow.getTime();
      const hitDiff = nextStorm.getTime() - utcNow.getTime();

      // Reset all phase states
      [buildupPhase, hitPhase].forEach(phase => {
        if (phase) phase.classList.remove('active', 'warning', 'critical');
      });

      // Current storm status and phase highlighting
      if (hitDiff <= 0) {
        // Storm has passed, calculate next week
        nextBuildup.setUTCDate(nextBuildup.getUTCDate() + 7);
        nextStorm.setUTCDate(nextStorm.getUTCDate() + 7);
        const newBuildupDiff = nextBuildup.getTime() - utcNow.getTime();
        const newHitDiff = nextStorm.getUTCDate() - utcNow.getTime();
        updatePhaseDisplay(buildupTimeEl, newBuildupDiff, nextBuildup);
        updatePhaseDisplay(hitTimeEl, newHitDiff, nextStorm);
      } else if (buildupDiff <= 0) {
        // Currently in buildup phase or storm is hitting
        updatePhaseDisplay(buildupTimeEl, 0, nextBuildup, 'ACTIVE');
        updatePhaseDisplay(hitTimeEl, hitDiff, nextStorm);
        if (hitDiff <= 300000) { // Less than 5 minutes to storm
          if (hitPhase) hitPhase.classList.add('critical');
        } else {
          if (hitPhase) hitPhase.classList.add('warning');
        }
        if (buildupPhase) buildupPhase.classList.add('active');
      } else {
        // Waiting for next storm
        updatePhaseDisplay(buildupTimeEl, buildupDiff, nextBuildup);
        updatePhaseDisplay(hitTimeEl, hitDiff, nextStorm);
        if (buildupDiff <= 3600000) { // Less than 1 hour to buildup
          if (buildupPhase) buildupPhase.classList.add('warning');
        }
      }
    }
    
    function updatePhaseDisplay(element, timeDiff, targetDate, status = null) {
      if (!element) return;
      
      if (status === 'ACTIVE') {
        element.textContent = 'NOW';
        return;
      }
      
      if (timeDiff <= 0) {
        element.textContent = 'PASSED';
        return;
      }
      
      const diffSec = Math.floor(timeDiff / 1000);
      const days = Math.floor(diffSec / 86400);
      const hours = Math.floor((diffSec % 86400) / 3600);
      const mins = Math.floor((diffSec % 3600) / 60);
      const secs = diffSec % 60;
      
      let timeStr = '';
      if (days > 0) {
        timeStr = `${days}d ${hours}h ${mins}m`;
      } else if (hours > 0) {
        timeStr = `${hours}h ${mins}m ${secs}s`;
      } else {
        timeStr = `${mins}m ${secs}s`;
      }
      
      // Add local time display based on selected server
      const localTime = formatTimeForTimezone(targetDate, selectedServerTimezone);
      element.textContent = `${timeStr} (${localTime})`;
    }
    
    function formatTimeForTimezone(date, timezone) {
      try {
        if (timezone === 'UTC') {
          return date.toISOString().substr(11, 5) + ' UTC';
        }
        
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: timezone,
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        
        const timezoneName = new Intl.DateTimeFormat('en-US', {
          timeZone: timezone,
          timeZoneName: 'short'
        }).formatToParts(date).find(part => part.type === 'timeZoneName').value;
        
        return formatter.format(date) + ' ' + timezoneName;
      } catch (error) {
        console.warn('Timezone formatting failed:', error);
        return date.toISOString().substr(11, 5) + ' UTC';
      }
    }

    // --- Time Mode Toggle (reverse logic: checked = UTC, unchecked = Local) ---
    document.getElementById('useLocalTime').addEventListener('change', function() {
      useLocalTime = !this.checked;
      updateTimeToggleHighlight();
    });
    // Set initial state: checked = UTC, unchecked = Local
    useLocalTime = !document.getElementById('useLocalTime').checked;
    updateTimeToggleHighlight();

    // --- Server Location Change Handler ---
    document.getElementById('serverLocation').addEventListener('change', function() {
      selectedServerTimezone = this.value;
      updateStormTimer(); // Immediately update timer display with new timezone
    });

    function updateTimeToggleHighlight() {
      document.getElementById('timeModeLabel').style.fontWeight = useLocalTime ? 'bold' : 'normal';
      document.getElementById('timeModeLabel').style.opacity = useLocalTime ? '1' : '0.5';
      document.getElementById('utcModeLabel').style.fontWeight = useLocalTime ? 'normal' : 'bold';
      document.getElementById('utcModeLabel').style.opacity = useLocalTime ? '0.5' : '1';
      // Visually update the switch to match logic
      document.getElementById('useLocalTime').checked = !useLocalTime;
    }    function autoSaveMap() {
      try {
        const saveData = { gridData, exploredGrid };
        localStorage.setItem('dd_map_autosave', JSON.stringify(saveData));
      } catch (error) {
        console.warn('Auto-save failed:', error);
        // Could implement fallback save mechanism here
      }
    }

    function autoLoadMap() {
      const saveData = localStorage.getItem('dd_map_autosave');
      if (!saveData) return;
      try {
        const parsed = JSON.parse(saveData);
        if (parsed && parsed.gridData && parsed.exploredGrid) {
          validateGridData(parsed.gridData);
          validateExploredGrid(parsed.exploredGrid);
          gridData = parsed.gridData;
          exploredGrid = parsed.exploredGrid;
          rerenderAllCells();
        }
      } catch (error) {
        console.warn('Auto-load failed:', error);
        localStorage.removeItem('dd_map_autosave'); // Clear corrupted data
      }
    }

    function onMapChange() {
      debouncedAutoSave();
    }

    const _oldRenderCellIcons = renderCellIcons;
    renderCellIcons = function(cell, icons) {
      _oldRenderCellIcons(cell, icons);
      onMapChange();
    };

    const _oldClearMap = clearMap;
    clearMap = function() {
      _oldClearMap();
      onMapChange();
    };

    const _oldExploreAllCells = exploreAllCells;
    exploreAllCells = function() {
      _oldExploreAllCells();
      onMapChange();
    };

    setInterval(debouncedAutoSave, 30000);
    setInterval(cleanupMemory, 60000); // Periodically clean up memory

    // Data validation utilities
    function validateGridData(data) {
      if (!Array.isArray(data) || data.length !== 9) {
        throw new Error('Invalid grid data: must be 9x9 array');
      }
      
      for (let row = 0; row < 9; row++) {
        if (!Array.isArray(data[row]) || data[row].length !== 9) {
          throw new Error(`Invalid grid data: row ${row} must be array of length 9`);
        }
        
        for (let col = 0; col < 9; col++) {
          if (!Array.isArray(data[row][col])) {
            throw new Error(`Invalid grid data: cell [${row}][${col}] must be array`);
          }
          
          // Validate icon names
          data[row][col].forEach((icon, idx) => {
            if (typeof icon !== 'string' || ![...resourcePoiIcons, ...houseIcons].includes(icon)) {
              console.warn(`Invalid icon at [${row}][${col}][${idx}]: ${icon}`);
              // Remove invalid icon
              data[row][col].splice(idx, 1);
            }
          });
        }
      }
      
      return true;
    }

    function validateExploredGrid(data) {
      if (!Array.isArray(data) || data.length !== 9) {
        throw new Error('Invalid explored grid: must be 9x9 array');
      }
      
      for (let row = 0; row < 9; row++) {
        if (!Array.isArray(data[row]) || data[row].length !== 9) {
          throw new Error(`Invalid explored grid: row ${row} must be array of length 9`);
        }
        
        for (let col = 0; col < 9; col++) {
          if (typeof data[row][col] !== 'boolean') {
            console.warn(`Invalid explored state at [${row}][${col}], converting to boolean`);
            data[row][col] = Boolean(data[row][col]);
          }
        }
      }
      
      return true;
    }

    function initializeApp() {
      renderLegend();
      initializeGrid();
      populateIconPicker();
      rerenderAllCells();
      updateTimeToggleHighlight();
      updateStormTimer();
      setInterval(updateStormTimer, 1000);
      window.addEventListener('resize', throttledResize);
    }

    initializeApp();

    document.getElementById('clearButton').onclick = clearMap;
    document.getElementById('exploreAllButton').onclick = exploreAllCells;
    document.getElementById('undoButton').onclick = undo;
    document.getElementById('redoButton').onclick = redo;

    document.getElementById('legendToggleBtn').onclick = function() {
      const legend = document.getElementById('legendPanel');
      const icon = document.getElementById('legendToggleIcon');
      legend.classList.toggle('collapsed');
      icon.textContent = legend.classList.contains('collapsed') ? '►' : '▼';
    };

    document.getElementById('legendToggleBtn').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.click();
      }
    });

    ['exploreAllButton','clearButton'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.title = el.textContent;
        el.setAttribute('aria-label', el.textContent);
        el.setAttribute('tabindex', '0');
      }
    });    gridContainer.addEventListener('click', function(e) {
      if (e.target === gridContainer) clearSelection();
    });    window.addEventListener('DOMContentLoaded', function() {
      autoLoadMapEnhanced();
    });    // --- Polish: Add tooltips to all controls ---
    const tooltipMappings = {
      'undoButton': 'Undo (Ctrl+Z)',
      'redoButton': 'Redo (Ctrl+Y)',
      'clearButton': 'Clear Map (Delete selected)',
      'exploreAllButton': 'Mark All Cells as Explored'
    };

    Object.entries(tooltipMappings).forEach(([id, tooltip]) => {
      const el = document.getElementById(id);
      if (el) {
        el.title = tooltip;
        el.setAttribute('aria-label', tooltip);
        el.setAttribute('tabindex', '0');
      }
    });

    // Status notification system
    function showNotification(message, type = 'info', duration = 3000) {
      // Remove existing notifications
      const existing = document.querySelector('.notification-toast');
      if (existing) existing.remove();
      
      const notification = document.createElement('div');
      notification.className = 'notification-toast';
      notification.textContent = message;
      
      // Style based on type
      const styles = {
        info: { background: '#2196F3', color: '#fff' },
        success: { background: '#4CAF50', color: '#fff' },
        warning: { background: '#FF9800', color: '#fff' },
        error: { background: '#f44336', color: '#fff' }
      };
      
      Object.assign(notification.style, {
        position: 'fixed',
        top: '20px',
        right: '20px',
        padding: '12px 20px',
        borderRadius: '4px',
        fontWeight: 'bold',
        fontSize: '14px',
        zIndex: '10000',
        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
        transform: 'translateX(100%)',
        transition: 'transform 0.3s ease-in-out',
        maxWidth: '300px',
        wordWrap: 'break-word',
        ...styles[type]
      });
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 10);
      
      // Auto remove
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => notification.remove(), 300);
      }, duration);
    }
  </script>
</body>
</html>
