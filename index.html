<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dune Awakening Deep Desert Mapping</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #000;
    }
    h1 {
      color: #fff;
    }
    p {
      color: #ccc;
    }
    .main-flex {
      display: flex;
      align-items: flex-start;
      gap: 40px;
    }
    .grid-outer {
      display: flex;
      flex-direction: column;
    }
    .grid-label-row,
    .grid-label-col {
      display: none !important; /* Hide top and side labels */
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(9, 100px);   /* Enlarged cells */
      grid-template-rows: repeat(9, 100px);      /* Enlarged cells */
      gap: 2px;
      background: transparent;
      box-shadow: 0 0 20px #222;
      width: 900px;
      height: 900px;
      z-index: 1;
    }
    .cell {
      border: 1.5px solid #222;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      background-color: transparent;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
      position: relative;
      overflow: hidden;
    }
    .cell:hover {
      background-color: rgba(255,255,255,0.1);
    }
    .cell-label {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 14px;
      color: #fff;
      opacity: 0.7;
      pointer-events: none;
      z-index: 2;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }
    .cell-icons {
      display: flex;
      flex-direction: column; /* Stack rows vertically */
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: flex-start;
      width: 100%;
      height: 100%;
      padding-top: 20px;
      z-index: 1;
    }
    .cell-icon-row {
      display: flex;
      flex-direction: row;
      margin-bottom: 2px;
    }
    .cell-icons img {
      width: 36px;
      height: 36px;
      margin: 2px;
      background: #222;
      border-radius: 4px;
      border: 1px solid #444;
    }
    .legend {
      margin-left: 40px;
      align-self: flex-start;
      color: #fff;
      background: rgba(30,30,30,0.7);
      padding: 10px 10px;
      border-radius: 8px;
      min-width: 120px;
      max-width: 160px;
      font-size: 13px;
      position: static;
      box-sizing: border-box;
    }
    .legend-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 1em;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      font-size: 13px;
    }
    .legend-item img {
      width: 20px;
      height: 20px;
      margin-right: 6px;
      background: #222;
      border-radius: 3px;
      border: 1px solid #444;
    }
    .controls {
      margin-top: 30px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Dune Awakening Deep Desert Mapping</h1>
  <p>Click on any cell to set its content. When youâ€™re finished updating the map, use the export button to review your grid or clear to start over.</p>
  <div class="main-flex">
    <div class="grid-outer">
      <div style="display:flex;">
        <div class="grid-container" id="gridContainer"></div>
      </div>
      <div class="controls" style="margin-top:30px; text-align:center;">
        <button id="clearButton">Clear Map</button>
        <button id="exportPngButton">Export as PNG</button>
        <button id="exportJsonButton">Export as JSON</button>
      </div>
    </div>
    <div class="legend">
      <div class="legend-title">Legend</div>
      <div id="legendIcons"></div>
    </div>
  </div>

  <!-- Icon Picker Modal -->
  <div id="iconPickerModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1000;">
    <div style="background:#fff; padding:20px; border-radius:8px; max-width:600px;">
      <h3>Select an Icon</h3>
      <div id="iconPickerGrid" style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;"></div>
      <!-- Add Check and Confirm buttons -->
      <div style="margin-top:10px; display:flex; gap:10px;">
        <button id="checkSelectionButton" type="button">Check</button>
        <button id="confirmSelectionButton" type="button">Confirm</button>
        <button onclick="closeIconPicker()">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const gridContainer = document.getElementById('gridContainer');
    let gridData = [];

    // List of PNG/SVG icon filenames (relative to your project)
    const iconList = [
      "IconAuthorizedBase.png",
      "IconCave.png",
      "IconHomeBase.png",
      "IconPoi.png",
      "IconShipwreck.png",
      "IconShipwreckX2.png",
      "IconSpice.png",
      "IconStravidium.png",
      "IconTestingStation.png",
      "IconTitanium.png"
    ];
    const iconNames = [
      "Authorized Base",
      "Cave",
      "Home Base",
      "POI",
      "Shipwreck",
      "Shipwreck x2",
      "Spice",
      "Stravidium",
      "Testing Station",
      "Titanium"
    ];
    const iconPath = "Icons/";

    let currentCell = null;

    // Make legend icons draggable
    function renderLegend() {
      const legend = document.getElementById('legendIcons');
      legend.innerHTML = '';
      iconList.forEach((icon, idx) => {
        legend.innerHTML += `
          <div class="legend-item" draggable="true" data-icon="${icon}">
            <img src="${iconPath + icon}" alt="${iconNames[idx]}">
            <span>${iconNames[idx]}</span>
          </div>
        `;
      });

      // Add dragstart event to legend icons
      document.querySelectorAll('.legend-item').forEach(item => {
        item.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', this.getAttribute('data-icon'));
        });
      });
    }

    // Initializes a 9x9 grid with reversed letter labels (I at top, A at bottom)
    function initializeGrid() {
      gridContainer.innerHTML = "";
      gridData = [];
      // Render from top (row 8, I) to bottom (row 0, A)
      for (let row = 8; row >= 0; row--) {
        gridData[row] = [];
        for (let col = 0; col < 9; col++) {
          gridData[row][col] = [];
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-row', row);
          cell.setAttribute('data-col', col);
          cell.innerHTML = "";
          cell.addEventListener('click', handleCellClick);
          gridContainer.appendChild(cell);
        }
      }
      makeCellsDroppable();
    }

    // Show icon picker when a cell is clicked
    function handleCellClick(event) {
      currentCell = event.currentTarget;
      document.getElementById('iconPickerModal').style.display = 'flex';
    }

    // Populate icon picker grid
    function populateIconPicker() {
      const grid = document.getElementById('iconPickerGrid');
      grid.innerHTML = "";
      iconList.forEach(icon => {
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = icon;
        img.style.width = "40px";
        img.style.height = "40px";
        img.style.cursor = "pointer";
        img.title = icon.replace('.png','').replace('Icon','');
        img.onclick = () => selectIcon(icon);
        grid.appendChild(img);
      });
    }

    // When an icon is selected, add/remove it in the cell (toggle)
    function selectIcon(icon) {
      if (currentCell) {
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        const idx = gridData[row][col].indexOf(icon);
        if (idx === -1) {
          gridData[row][col].push(icon); // Add icon
        } else {
          gridData[row][col].splice(idx, 1); // Remove icon if already present
        }
        renderCellIcons(currentCell, gridData[row][col]);
      }
      // Keep picker open for multi-select
    }

    // Helper to render all icons in a cell and show cell label (I at top, A at bottom)
    function renderCellIcons(cell, icons) {
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      // Reverse: I (row 8) at top, A (row 0) at bottom
      const label = String.fromCharCode(65 + parseInt(row)) + (parseInt(col) + 1);

      // Arrange icons in a 3x3 grid
      let html = `<span class="cell-label">${label}</span><div class="cell-icons" style="display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);width:100%;height:100%;padding-top:20px;">`;
      for (let i = 0; i < 9; i++) {
        if (icons[i]) {
          html += `<div style="display:flex;align-items:center;justify-content:center;"><img src="${iconPath + icons[i]}" alt="" draggable="false" style="width:32px;height:32px;"></div>`;
        } else {
          html += `<div></div>`;
        }
      }
      html += `</div>`;
      cell.innerHTML = html;
    }

    // Close the icon picker
    function closeIconPicker() {
      document.getElementById('iconPickerModal').style.display = 'none';
      currentCell = null;
    }

    // Outputs the grid data in a coordinate: icons format (from A at top to I at bottom)
    function exportMapData() {
      let output = "Cell\t\tIcons\n";
      output += "-------------------------\n";
      // Loop from row 0 (A/top) to row 8 (I/bottom)
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          if (gridData[row][col].length) {
            const coord = String.fromCharCode(65 + row) + (col + 1);
            const icons = gridData[row][col].map(i => iconNames[iconList.indexOf(i)]).join(", ");
            output += coord + "\t" + icons + "\n";
          }
        }
      }
      if (output === "Cell\t\tIcons\n-------------------------\n") {
        output += "(No icons placed on the map)";
      }
      alert("Exported Map Data:\n" + output);
      console.log("Exported Map Data:\n" + output);
    }

    // Exports the grid data as JSON
    function exportMapDataAsJson() {
      // Define the layers as in your example
      const layers = [
        { Name: "Shipwreck", IconName: "Shipwreck", Description: "Shipwreck" },
        { Name: "TestingStation", IconName: "TestingStation", Description: "Testing station" },
        { Name: "Cave", IconName: "Cave", Description: "Cave" },
        { Name: "Spice", IconName: "Spice", Description: "Spice ring" },
        { Name: "Titanium", IconName: "Titanium", Description: "Titanium" },
        { Name: "Stravidium", IconName: "Stravidium", Description: "Stravidium" },
        { Name: "Poi", IconName: "Poi", Description: "Point of interest" },
        { Name: "AuthorizedBase", IconName: "AuthorizedBase", Description: "Guild base" }
      ];

      // Collect all placed icons as simple entries (e.g. "I1,Shipwreck" for top row, "A1,..." for bottom)
      const simpleEntries = [];
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          gridData[row][col].forEach(icon => {
            let iconName = icon.replace(/^Icon/, '').replace(/\.png$/i, '');
            // Reverse the letter order: I (row 0/top) ... A (row 8/bottom)
            const coord = String.fromCharCode(65 + (8 - row)) + (col + 1);
            simpleEntries.push(`${coord},${iconName}`);
          });
        }
      }

      const json = {
        GridSize: 9,
        IconSize: 48,
        GridMapSize: 150,
        IconsFolder: "Icons",
        Layers: layers,
        ActiveMap: {
          Help: "This is a sample map. It contains a list of simple entries that is used for easy entering of map coordinates by using comma or semicolon separation of entries. Ex 'A1,G4'\r\nYou may also enter detailed entries that include a grid location, name, description and coordinates within the grid.\r\n",
          ScoutedGrids: "",
          SimpleEntries: simpleEntries,
          DetailedEntries: []
        }
      };

      // Download as JSON file
      const blob = new Blob([JSON.stringify(json, null, 2)], { type: "application/json" });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = "map_export.json";
      link.click();
    }

    // Clears the grid after confirmation
    function clearMap() {
      if (confirm("This will clear all map data. Are you sure you want to continue?")) {
        initializeGrid();
        rerenderAllCells();
      }
    }

    // Exports the grid as a PNG image (draws SVG icons, from I to A)
    function exportAsPng() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const cellSize = 150; // ENLARGED
      const gap = 2;
      const gridSize = 9;
      const backgroundSrc = 'background.jpg';

      // Add extra space at the top for the date
      const dateHeight = 60;
      canvas.width = gridSize * (cellSize + gap);
      canvas.height = gridSize * (cellSize + gap) + dateHeight;

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = src;
        });
      }

      // Gather all unique icons used in the grid
      const usedIcons = new Set();
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          gridData[row][col].forEach(icon => usedIcons.add(icon));
        }
      }

      const iconPromises = {};
      usedIcons.forEach(icon => {
        iconPromises[icon] = loadImage(iconPath + icon);
      });

      Promise.all([
        loadImage(backgroundSrc),
        ...Object.values(iconPromises)
      ]).then(([backgroundImage, ...iconImages]) => {
        const iconMap = {};
        let i = 0;
        for (const icon of usedIcons) {
          iconMap[icon] = iconImages[i++];
        }

        // Draw black background for date area
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, dateHeight);

        // Draw date at the top
        ctx.font = "bold 32px Arial";
        ctx.fillStyle = "#fff";
        ctx.textBaseline = "middle";
        const dateStr = new Date().toUTCString(); // Use UTC time
        ctx.fillText(dateStr, 20, dateHeight / 2);

        // Draw faded background image for grid area
        ctx.globalAlpha = 0.4;
        ctx.drawImage(backgroundImage, 0, dateHeight, canvas.width, canvas.height - dateHeight);
        ctx.globalAlpha = 1.0;

        // Draw the grid and icons (row 0 at top, 8 at bottom)
        for (let row = 0; row < gridSize; row++) {
          for (let col = 0; col < gridSize; col++) {
            const x = col * (cellSize + gap);
            const y = dateHeight + row * (cellSize + gap);

            // Draw cell border
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, cellSize, cellSize);

            // Draw cell label using I (top) to A (bottom)
            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.textBaseline = "top";
            ctx.fillText(String.fromCharCode(65 + (8 - row)) + (col + 1), x + 8, y + 8);

            // Draw up to 9 icons in a 3x3 grid, enlarge and center based on count
            const icons = gridData[row][col];
            const n = icons.length;
            if (n > 0) {
              let iconSize, positions;
              if (n === 1) {
                iconSize = 90;
                positions = [[cellSize / 2, cellSize / 2 + 10]];
              } else if (n === 2) {
                iconSize = 70;
                positions = [
                  [cellSize / 2 - 35, cellSize / 2 + 10],
                  [cellSize / 2 + 35, cellSize / 2 + 10]
                ];
              } else if (n === 3) {
                iconSize = 60;
                positions = [
                  [cellSize / 2, cellSize / 2 - 30],
                  [cellSize / 2 - 38, cellSize / 2 + 32],
                  [cellSize / 2 + 38, cellSize / 2 + 32]
                ];
              } else if (n === 4) {
                iconSize = 54;
                positions = [
                  [cellSize / 2 - 32, cellSize / 2 - 24],
                  [cellSize / 2 + 32, cellSize / 2 - 24],
                  [cellSize / 2 - 32, cellSize / 2 + 32],
                  [cellSize / 2 + 32, cellSize / 2 + 32]
                ];
              } else {
                // Arrange in a 3x3 grid for 5-9 icons
                iconSize = 40;
                positions = [];
                const grid = 3;
                const offset = (cellSize - grid * iconSize) / 2;
                for (let i = 0; i < Math.min(n, 9); i++) {
                  const gx = i % 3;
                  const gy = Math.floor(i / 3);
                  positions.push([
                    offset + gx * iconSize + iconSize / 2,
                    30 + offset + gy * iconSize + iconSize / 2
                  ]);
                }
              }
              for (let i = 0; i < Math.min(n, 9); i++) {
                const icon = icons[i];
                if (icon && iconMap[icon]) {
                  ctx.drawImage(
                    iconMap[icon],
                    x + positions[i][0] - iconSize / 2,
                    y + positions[i][1] - iconSize / 2,
                    iconSize,
                    iconSize
                  );
                }
              }
            }
          }
        }

        const link = document.createElement('a');
        link.download = 'grid.png';
        link.href = canvas.toDataURL();
        link.click();
      });
    }

    // Make grid cells droppable
    function makeCellsDroppable() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.addEventListener('dragover', function (e) {
          e.preventDefault();
        });
        cell.addEventListener('drop', function (e) {
          e.preventDefault();
          const icon = e.dataTransfer.getData('text/plain');
          const row = this.getAttribute('data-row');
          const col = this.getAttribute('data-col');
          if (icon && gridData[row][col].indexOf(icon) === -1) {
            gridData[row][col].push(icon);
            renderCellIcons(this, gridData[row][col]);
          }
        });
      });
    }

    // When reloading the grid, re-render icons in each cell (I at top, A at bottom)
    function rerenderAllCells() {
      const cells = document.querySelectorAll('.cell');
      let idx = 0;
      for (let row = 8; row >= 0; row--) {
        for (let col = 0; col < 9; col++) {
          renderCellIcons(cells[idx++], gridData[row][col]);
        }
      }
      makeCellsDroppable();
    }

    // Add check and confirm button logic
    document.getElementById('checkSelectionButton').onclick = function() {
      if (currentCell) {
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        const icons = gridData[row][col];
        if (icons.length === 0) {
          alert("No icons selected for this cell.");
        } else {
          alert(
            "Cell " +
            String.fromCharCode(65 + parseInt(row)) +
            (parseInt(col) + 1) +
            " contains: " +
            icons.map(i => iconNames[iconList.indexOf(i)]).join(", ")
          );
        }
      }
    };
    document.getElementById('confirmSelectionButton').onclick = function() {
      closeIconPicker();
    };

    // Initialize everything on page load
    renderLegend();
    initializeGrid();
    populateIconPicker();
    rerenderAllCells();

    // Button event listeners
    document.getElementById('clearButton').onclick = clearMap;
    document.getElementById('exportPngButton').onclick = exportAsPng;
    document.getElementById('exportJsonButton').onclick = exportMapDataAsJson;
  </script>
</body>
</html>
