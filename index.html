<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Added mobile viewport -->
  <title>Dune Awakening Deep Desert Mapping</title>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #000;
      display: block;
      flex-direction: unset;
      align-items: unset;
    }
    h1 {
      color: #fff;
      font-size: 2.2em;
      letter-spacing: 0.03em;
      text-align: center;
    }
    .main-flex {
      display: flex;
      align-items: flex-start;
      justify-content: center; /* Center the grid and side panels horizontally */
      gap: 40px;
      width: 100%;
      max-width: none;
    }
    .description-box {
      background: rgba(30,30,30,0.85);
      color: #ffe066;
      border-radius: 10px;
      padding: 18px;
      min-width: 220px;
      max-width: 260px;
      margin-right: 32px;
      font-size: 1em;
      box-shadow: 0 2px 12px #2228;
      align-self: flex-start;
    }
    .description-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 8px;
      letter-spacing: 0.03em;
    }
    .description-content {
      color: #ffe066;
      font-size: 0.98em;
      line-height: 1.6;
    }
    .grid-outer {
      display: flex;
      flex-direction: column;
      align-items: center; /* Center the grid horizontally */
    }
    .grid-label-row,
    .grid-label-col {
      display: none !important;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(9, 100px);
      grid-template-rows: repeat(9, 100px);
      gap: 2px;
      background: transparent;
      box-shadow: none;
      width: 900px;
      height: 900px;
      z-index: 1;
      position: relative;
      touch-action: manipulation;
    }
    @media (max-width: 1000px) {
      .grid-container {
        width: 98vw;
        height: 98vw;
        max-width: 98vw;
        max-height: 98vw;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }
    }
    .cell {
      border: 1.5px solid #222;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      background-color: transparent;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
      position: relative;
      overflow: hidden;
      touch-action: manipulation;
    }
    .cell:hover, .cell:active {
      background-color: rgba(255,255,255,0.1);
    }
    .cell-label {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 14px;
      color: #fff;
      opacity: 0.7;
      pointer-events: none;
      z-index: 2;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }
    .cell-icons {
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: flex-start;
      width: 100%;
      height: 100%;
      padding-top: 20px;
      z-index: 1;
    }
    .cell-icon-row {
      display: flex;
      flex-direction: row;
      margin-bottom: 2px;
    }
    .cell-icons img {
      width: 36px;
      height: 36px;
      margin: 2px;
      background: #222;
      border-radius: 4px;
      border: 1px solid #444;
      pointer-events: none;
      user-select: none;
    }
    .legend {
      margin-left: 40px;
      align-self: flex-start;
      color: #fff;
      background: rgba(30,30,30,0.7);
      padding: 10px 10px 18px 10px;
      border-radius: 8px;
      min-width: 140px;
      max-width: 180px;
      font-size: 13px;
      position: static;
      box-sizing: border-box;
      width: 180px;
      transition: max-height 0.3s, padding 0.3s;
      overflow: hidden;
    }
    .legend.collapsed {
      max-height: 38px;
      padding-bottom: 0;
    }
    .legend-toggle {
      cursor: pointer;
      color: #ffe066;
      font-size: 1.1em;
      font-weight: bold;
      background: none;
      border: none;
      outline: none;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-toggle:focus {
      outline: 2px solid #ffe066;
    }
    .controls {
      margin-top: 30px;
      display: block;
      justify-content: unset;
      gap: unset;
      flex-wrap: unset;
      width: auto;
    }
    .cell.unexplored::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(30,30,30,0.55);
      pointer-events: none;
      z-index: 2;
    }
    .cell.explored::after {
      display: none;
    }
    .explored-toggle {
      color: #ffe066 !important;
      text-shadow: 0 0 2px #222, 0 0 8px #ffe066;
    }
    .cell.unexplored .explored-toggle {
      color: #ffe066 !important;
      opacity: 0.7;
    }
    #useLocalTime {
      accent-color: #ffe066;
    }
    #timeModeLabel {
      color: #fff700;
      font-weight: bold;
    }
    .side-controls {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-top: 24px;
      align-items: center; /* Center the buttons and toggle horizontally */
    }
    .time-toggle {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 4px;
      width: 100%;
    }
    .switch-label {
      display: flex;
      align-items: center;
      color: #ffe066;
      font-weight: bold;
      font-size: 1.05em;
      gap: 6px;
      min-width: 0;
      width: 100%;
      justify-content: space-between;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      margin: 0 2px;
      flex-shrink: 0;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #444;
      border-radius: 24px;
      transition: background 0.2s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: #ffe066;
      border-radius: 50%;
      transition: transform 0.2s;
      box-shadow: 0 1px 4px #2226;
    }
    .switch input:checked + .slider {
      background: #ffe066;
    }
    .switch input:checked + .slider:before {
      background: #444;
      transform: translateX(20px);
    }
    .pretty-btn {
      background: linear-gradient(90deg, #ffe066 0%, #ffd700 100%);
      color: #222;
      border: none;
      border-radius: 22px;
      padding: 14px 32px;
      min-width: 180px;
      font-size: 1.08em;
      font-weight: bold;
      letter-spacing: 0.03em;
      box-shadow: 0 2px 8px #2224;
      cursor: pointer;
      margin: 0 0 10px 0;
      transition: background 0.2s, color 0.2s, transform 0.1s;
      outline: none;
      display: inline-block;
      touch-action: manipulation;
    }
    .pretty-btn:hover, .pretty-btn:focus {
      background: linear-gradient(90deg, #fff6b0 0%, #ffe066 100%);
      color: #111;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 16px #ffe06655;
    }
    #stormTimer {
      text-align: left;
      width: auto;
      margin-left: 0;
      margin-right: 0;
    }

    /* --- Mobile Mode --- */
    @media (max-width: 1000px) {
      .main-flex {
        flex-direction: column;
        align-items: center;
        gap: 24px;
        max-width: 100vw;
      }
      .description-box,
      .legend {
        margin: 0 auto;
        min-width: 0;
        max-width: 98vw;
        width: 98vw;
      }
      .controls,
      #stormTimer {
        width: 98vw;
        min-width: 0;
        max-width: 98vw;
      }
      .grid-container {
        width: 98vw;
        height: 98vw;
        max-width: 98vw;
        max-height: 98vw;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }
      .cell {
        font-size: 10px;
      }
      .cell-label {
        font-size: 11px;
      }
      .cell-icons img {
        width: 22px;
        height: 22px;
      }
      .legend {
        min-width: 0;
        max-width: 98vw;
        width: 98vw;
        font-size: 12px;
        padding: 8px 4px 12px 4px;
      }
      .legend.collapsed {
        max-height: 38px;
        padding-bottom: 0;
      }
      .legend-item img {
        width: 24px;
        height: 24px;
      }
      .pretty-btn {
        min-width: 120px;
        padding: 10px 10px;
        font-size: 1em;
      }
    }
    [aria-label][tabindex] {
      outline: none;
    }
    [aria-label][tabindex]:focus {
      outline: 2px solid #ffe066;
    }

    .legend-item img {
      width: 36px;
      height: 36px;
    }

    body.high-contrast {
      background: #000 !important;
      color: #fff !important;
    }
    body.high-contrast .legend,
    body.high-contrast .description-box,
    body.high-contrast .side-controls,
    body.high-contrast .controls {
      background: #000 !important;
      color: #fff !important;
      border: 2px solid #fff700 !important;
    }
    body.high-contrast .cell {
      border: 2px solid #fff700 !important;
      background: #111 !important;
      color: #fff !important;
    }
    body.high-contrast .cell-label {
      color: #fff700 !important;
      text-shadow: none !important;
    }
    body.high-contrast .pretty-btn {
      background: #000 !important;
      color: #fff700 !important;
      border: 2px solid #fff700 !important;
      box-shadow: none !important;
    }
    body.high-contrast .pretty-btn:hover, body.high-contrast .pretty-btn:focus {
      background: #222 !important;
      color: #fff !important;
    }
    body.high-contrast .legend-toggle {
      color: #fff700 !important;
    }
    body.high-contrast .explored-toggle {
      color: #fff700 !important;
      text-shadow: none !important;
    }
  </style>
</head>
<body>
  <div style="display:flex; align-items:center; justify-content:center; margin-bottom:10px;">
    <img src="arrakis.png" alt="Arrakis Icon" style="width:54px; height:54px; margin-right:16px; vertical-align:middle;">
    <h1 style="color:#fff; margin:0;">Dune Awakening Deep Desert Mapping</h1>
  </div>
  <div id="stormTimer" style="color:#ffe066; font-size:1.15em; font-weight:bold; margin-bottom:12px; text-align:center;">
    Next Coriolis Storm: calculating...
  </div>
  <div class="main-flex">
    <div class="description-box">
      <div class="description-title">How to Use</div>
      <div class="description-content">
        - Click on any cell to set its content, or drag and drop from Legend.<br>
        - When you’re finished updating the map, use the export to PNG button to download your grid or clear to start over.<br>
        - You can import/export your map as JSON, or save/load named versions.<br>
        - You can set the time to either UTC or your local time for the export to png.
      </div>
    </div>
    <!-- Unified controls row under description box -->
    <div class="main-controls" style="width:100%; display:flex; flex-direction:row; flex-wrap:wrap; justify-content:center; align-items:center; gap:14px; margin-bottom:18px;">
      <button id="saveVersionButton" class="pretty-btn">Save Map</button>
      <button id="loadVersionButton" class="pretty-btn">Load Map</button>
      <button id="exportJsonButton" class="pretty-btn">Export as JSON</button>
      <button id="importJsonButton" class="pretty-btn">Import from JSON</button>
      <input type="file" id="importJsonInput" accept="application/json" style="display:none;" />
      <button id="exportPngButton" class="pretty-btn">Export as PNG</button>
      <button id="shareLinkButton" class="pretty-btn">Get Shareable Link</button>
    </div>
    <div class="grid-outer">
      <div style="display:flex;">
        <div class="grid-container" id="gridContainer" role="grid" aria-label="Map grid"></div>
      </div>
    </div>
    <div class="legend" id="legendPanel">
      <button class="legend-toggle" id="legendToggleBtn" aria-label="Toggle legend" tabindex="0" title="Show/hide legend">
        <span id="legendToggleIcon">▼</span>
        <span class="legend-title">Legend</span>
      </button>
      <div id="legendIcons" role="list" aria-label="Map legend icons"></div>
    </div>
    <div class="side-controls">
      <div class="time-toggle">
        <label class="switch-label">
          <span id="timeModeLabel" style="margin-right:10px;">Local</span>
          <label class="switch">
            <input type="checkbox" id="useLocalTime" checked>
            <span class="slider"></span>
          </label>
          <span id="utcModeLabel" style="margin-left:10px;">UTC</span>
        </label>
      </div>
      <button id="exploreAllButton" class="pretty-btn">Explore All</button>
      <button id="undoButton" class="pretty-btn" title="Undo (Ctrl+Z)">Undo</button>
      <button id="redoButton" class="pretty-btn" title="Redo (Ctrl+Y)">Redo</button>
      <button id="clearButton" class="pretty-btn">Clear Map</button>
      <button id="highContrastBtn" class="pretty-btn" aria-pressed="false" title="Toggle high contrast mode">High Contrast</button>
    </div>
  </div>

  <!-- Icon Picker Modal -->
  <div id="iconPickerModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.15); align-items:center; justify-content:center; z-index:1000;">
    <div style="background:rgba(255,255,255,0.85); padding:20px; border-radius:8px; max-width:600px; box-shadow:0 4px 32px #0008; position:relative;">
      <h3>Select an Icon</h3>
      <div id="iconPickerGrid" style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;"></div>
      <div style="margin-top:10px; display:flex; gap:10px;">
        <button id="confirmSelectionButton" type="button">Confirm</button>
        <button onclick="closeIconPicker()">Cancel</button>
      </div>
      <div id="iconPickerFeedback" style="display:none; position:absolute; top:10px; right:20px; background:#ffe066; color:#222; font-weight:bold; padding:6px 18px; border-radius:8px; box-shadow:0 2px 8px #2224; z-index:10;">Icon placed!</div>
    </div>
  </div>

  <script>
    let useLocalTime = true;
    const gridContainer = document.getElementById('gridContainer');
    let gridData = [];
    let exploredGrid = [];
    let undoStack = [];
    let redoStack = [];
    let selectedCells = new Set();
    let isSelecting = false;

    const iconList = [
      "IconAuthorizedBase.png",
      "IconCave.png",
      "IconHomeBase.png",
      "IconPoi.png",
      "IconShipwreck.png",
      "IconShipwreckX2.png",
      "IconSpice.png",
      "IconStravidium.png",
      "IconTestingStation.png",
      "IconTitanium.png"
    ];
    const iconNames = [
      "Authorized Base",
      "Cave",
      "Home Base",
      "POI",
      "Shipwreck",
      "Shipwreck x2",
      "Spice",
      "Stravidium",
      "Testing Station",
      "Titanium"
    ];
    const iconPath = "Icons/";
    let currentCell = null;

    // Add debounce utility for performance
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Add throttle utility for high-frequency events
    function throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    }

    // Enhanced image loading with fallback and retry mechanism
    function loadImageWithFallback(src, fallbackSrc = null, retries = 2) {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        
        function attemptLoad(imageSrc) {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => {
            attempts++;
            if (attempts < retries && fallbackSrc) {
              console.warn(`Failed to load ${imageSrc}, trying fallback...`);
              attemptLoad(fallbackSrc);
            } else if (attempts < retries) {
              console.warn(`Failed to load ${imageSrc}, retrying... (${attempts}/${retries})`);
              setTimeout(() => attemptLoad(imageSrc), 1000);
            } else {
              console.error(`Failed to load image after ${retries} attempts: ${imageSrc}`);
              reject(new Error(`Image loading failed: ${imageSrc}`));
            }
          };
          img.src = imageSrc;
        }
        
        attemptLoad(src);
      });
    }

    // Improved renderLegend with error handling
    function renderLegendSafe() {
      try {
        renderLegend();
      } catch (error) {
        console.error('Failed to render legend:', error);
        // Show user-friendly error message
        const legend = document.getElementById('legendIcons');
        if (legend) {
          legend.innerHTML = '<p style="color: #ff6666;">Failed to load legend icons. Please refresh the page.</p>';
        }
      }
    }

    // Debounced auto-save for better performance
    const debouncedAutoSave = debounce(autoSaveMap, 2000);

    // Throttled resize handler for better performance
    const throttledResize = throttle(function() {
      // Re-calculate grid dimensions on resize if needed
      rerenderAllCells();
    }, 250);

    // Memory management: Clear unused undo states periodically
    function cleanupMemory() {
      if (undoStack.length > 50) {
        undoStack.splice(0, undoStack.length - 50);
      }
      if (redoStack.length > 50) {
        redoStack.splice(0, redoStack.length - 50);
      }
    }

    function pushUndo() {
      try {
        undoStack.push({
          gridData: JSON.parse(JSON.stringify(gridData)),
          exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
          selectedCells: Array.from(selectedCells)
        });
        if (undoStack.length > 100) undoStack.shift();
        redoStack = [];
      } catch (error) {
        console.error('Failed to create undo state:', error);
      }
    }

    function undo() {
      if (undoStack.length === 0) return;
      redoStack.push({
        gridData: JSON.parse(JSON.stringify(gridData)),
        exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
        selectedCells: Array.from(selectedCells)
      });
      const prev = undoStack.pop();
      gridData = prev.gridData;
      exploredGrid = prev.exploredGrid;
      selectedCells = new Set(prev.selectedCells);
      rerenderAllCells();
      renderSelection();
    }

    function redo() {
      if (redoStack.length === 0) return;
      undoStack.push({
        gridData: JSON.parse(JSON.stringify(gridData)),
        exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
        selectedCells: Array.from(selectedCells)
      });
      const next = redoStack.pop();
      gridData = next.gridData;
      exploredGrid = next.exploredGrid;
      selectedCells = new Set(next.selectedCells);
      rerenderAllCells();
      renderSelection();
    }

    function cellKey(row, col) {
      return row + "," + col;
    }

    function renderLegend() {
      const legend = document.getElementById('legendIcons');
      legend.innerHTML = '';
      iconList.forEach((icon, idx) => {
        const div = document.createElement('div');
        div.className = 'legend-item';
        div.setAttribute('draggable', 'true');
        div.setAttribute('data-icon', icon);
        div.setAttribute('tabindex', '0');
        div.setAttribute('aria-label', iconNames[idx] + ' (drag to grid or click to select)');
        div.title = 'Drag to grid or click to select';
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = iconNames[idx];
        img.title = iconNames[idx];
        const span = document.createElement('span');
        span.textContent = iconNames[idx];
        div.appendChild(img);
        div.appendChild(span);
        legend.appendChild(div);
        div.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', this.getAttribute('data-icon'));
        });
        div.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
          }
        });
      });
    }

    function initializeGrid() {
      gridContainer.innerHTML = "";
      gridData = [];
      exploredGrid = [];
      for (let row = 8; row >= 0; row--) {
        gridData[row] = [];
        exploredGrid[row] = [];
        for (let col = 0; col < 9; col++) {
          gridData[row][col] = [];
          exploredGrid[row][col] = false;
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-row', row);
          cell.setAttribute('data-col', col);
          cell.setAttribute('tabindex', '0');
          cell.setAttribute('aria-label', `Grid cell ${String.fromCharCode(65+row)}${col+1}`);
          cell.title = `Grid cell ${String.fromCharCode(65+row)}${col+1}`;
          cell.innerHTML = "";
          cell.addEventListener('click', handleCellClick);
          cell.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleCellClick({currentTarget: cell});
            }
          });
          gridContainer.appendChild(cell);
        }
      }
      makeCellsDroppable();
    }

    function handleCellClick(event) {
      const cell = event.currentTarget;
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      if (event.shiftKey) {
        // Multi-select
        const key = cellKey(row, col);
        if (selectedCells.has(key)) {
          selectedCells.delete(key);
        } else {
          selectedCells.add(key);
        }
        renderSelection();
        return;
      }
      if (selectedCells.size > 1) {
        // Batch edit: open icon picker for all selected
        currentCell = null;
        document.getElementById('iconPickerModal').style.display = 'flex';
      } else {
        currentCell = cell;
        document.getElementById('iconPickerModal').style.display = 'flex';
      }
    }

    function renderSelection() {
      document.querySelectorAll('.cell').forEach(cell => {
        const row = cell.getAttribute('data-row');
        const col = cell.getAttribute('data-col');
        const key = cellKey(row, col);
        if (selectedCells.has(key)) {
          cell.style.outline = '3px solid #ffe066';
          cell.style.boxShadow = '0 0 8px #ffe066cc';
        } else {
          cell.style.outline = '';
          cell.style.boxShadow = '';
        }
      });
    }

    function clearSelection() {
      selectedCells.clear();
      renderSelection();
    }

    function populateIconPicker() {
      const grid = document.getElementById('iconPickerGrid');
      grid.innerHTML = "";
      let selectedIcon = null;

      // Determine which icons are present in the current cell or all selected cells
      let presentIcons = new Set();
      if (selectedCells.size > 1) {
        // Multi-cell: collect all icons present in any selected cell
        selectedCells.forEach(key => {
          const [row, col] = key.split(',');
          gridData[row][col].forEach(icon => presentIcons.add(icon));
        });
      } else if (currentCell) {
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        gridData[row][col].forEach(icon => presentIcons.add(icon));
      }

      iconList.forEach(icon => {
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = icon;
        img.style.width = "24px";
        img.style.height = "24px";
        img.style.cursor = "pointer";
        img.style.border = presentIcons.has(icon) ? "2.5px solid #a259e6" : "2px solid transparent";
        img.style.borderRadius = "6px";
        img.title = icon.replace('.png','').replace('Icon','');
        img.onclick = () => {
          // Remove border from all icons
          Array.from(grid.children).forEach(child => {
            // Only remove border if not present in the cell(s)
            if (!presentIcons.has(child.alt)) {
              child.style.border = "2px solid transparent";
            }
          });
          img.style.border = "2.5px solid #a259e6";
          selectedIcon = icon;
          selectIcon(icon);
        };
        grid.appendChild(img);
      });
    }    // Batch icon selection for multi-cell
    function selectIcon(icon) {
      let placed = false;
      if (selectedCells.size > 1) {
        pushUndo();
        selectedCells.forEach(key => {
          const [row, col] = key.split(',');
          const idx = gridData[row][col].indexOf(icon);
          if (idx === -1) {
            gridData[row][col].push(icon);
            placed = true;
          } else {
            gridData[row][col].splice(idx, 1);
            placed = true;
          }
        });
        rerenderAllCells();
        renderSelection();
      } else if (currentCell) {
        pushUndo();
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        const idx = gridData[row][col].indexOf(icon);
        if (idx === -1) {
          gridData[row][col].push(icon);
          placed = true;
        } else {
          gridData[row][col].splice(idx, 1);
          placed = true;
        }
        renderCellIcons(currentCell, gridData[row][col]);
      }
      if (placed) {
        showIconPickerFeedback();
      }
    }

    function showIconPickerFeedback() {
      const feedback = document.getElementById('iconPickerFeedback');
      if (!feedback) return;
      feedback.textContent = 'Icon placed!';
      feedback.style.display = 'block';
      feedback.style.opacity = '1';
      setTimeout(() => {
        feedback.style.transition = 'opacity 0.5s';
        feedback.style.opacity = '0';
        setTimeout(() => {
          feedback.style.display = 'none';
          feedback.style.transition = '';
        }, 500);
      }, 600);
    }

    function renderCellIcons(cell, icons) {
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      const label = String.fromCharCode(65 + parseInt(row)) + (parseInt(col) + 1);

      if (icons.length > 0 && !exploredGrid[row][col]) {
        exploredGrid[row][col] = true;
      }

      const explored = exploredGrid[row][col];
      let checkHtml = explored
        ? `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark unexplored">&#x2714;</span>`
        : `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark explored">&#x25A2;</span>`;

      let exploredClass = explored ? "explored" : "unexplored";

      // Build the cell content safely
      const wrapper = document.createElement('div');
      wrapper.innerHTML = `<span class="cell-label"></span>
        <div class="cell-icons" style="display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);width:100%;height:100%;padding-top:20px;"></div>${checkHtml}`;

      // Set label safely
      wrapper.querySelector('.cell-label').textContent = label;

      // Add icons safely
      const iconsGrid = wrapper.querySelector('.cell-icons');
      for (let i = 0; i < 9; i++) {
        const iconDiv = document.createElement('div');
        iconDiv.style.display = "flex";
        iconDiv.style.alignItems = "center";
        iconDiv.style.justifyContent = "center";
        if (icons[i]) {
          const img = document.createElement('img');
          img.src = iconPath + icons[i];
          img.alt = "";
          img.draggable = false;
          img.style.width = "32px";
          img.style.height = "32px";
          iconDiv.appendChild(img);
        }
        iconsGrid.appendChild(iconDiv);
      }

      // Replace cell content
      cell.innerHTML = '';
      Array.from(wrapper.childNodes).forEach(n => cell.appendChild(n));
      cell.classList.remove("explored", "unexplored");
      cell.classList.add(exploredClass);

      const toggle = cell.querySelector('.explored-toggle');
      if (toggle) {
        toggle.onclick = (e) => {
          e.stopPropagation();
          if (gridData[row][col].length === 0) {
            exploredGrid[row][col] = !exploredGrid[row][col];
            renderCellIcons(cell, icons);
          }
        };
        toggle.style.opacity = explored ? "1" : "0.5";
      }
      onMapChange();
    }

    function closeIconPicker() {
      document.getElementById('iconPickerModal').style.display = 'none';
      currentCell = null;
    }

    function exportMapData() {
      let output = "Cell\t\tIcons\n";
      output += "-------------------------\n";
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          if (gridData[row][col].length) {
            const coord = String.fromCharCode(65 + row) + (col + 1);
            const icons = gridData[row][col].map(i => iconNames[iconList.indexOf(i)]).join(", ");
            output += coord + "\t" + icons + "\n";
          }
        }
      }
      if (output === "Cell\t\tIcons\n-------------------------\n") {
        output += "(No icons placed on the map)";
      }
      alert("Exported Map Data:\n" + output);
      console.log("Exported Map Data:\n" + output);
    }

    function exportMapDataAsJson() {
      const layers = [
        { Name: "Shipwreck", IconName: "Shipwreck", Description: "Shipwreck" },
        { Name: "TestingStation", IconName: "TestingStation", Description: "Testing station" },
        { Name: "Cave", IconName: "Cave", Description: "Cave" },
        { Name: "Spice", IconName: "Spice", Description: "Spice ring" },
        { Name: "Titanium", IconName: "Titanium", Description: "Titanium" },
        { Name: "Stravidium", IconName: "Stravidium", Description: "Stravidium" },
        { Name: "Poi", IconName: "Poi", Description: "Point of interest" },
        { Name: "AuthorizedBase", IconName: "AuthorizedBase", Description: "Guild base" }
      ];

      const simpleEntries = [];
      for (let row = 8; row >= 0; row--) {
        for (let col = 0; col < 9; col++) {
          gridData[row][col].forEach(icon => {
            let iconName = icon.replace(/^Icon/, '').replace(/\.png$/i, '');
            const coord = String.fromCharCode(65 + row) + (col + 1);
            simpleEntries.push(`${coord},${iconName}`);
          });
        }
      }

      const json = {
        GridSize: 9,
        IconSize: 48,
        GridMapSize: 150,
        IconsFolder: "Icons",
        Layers: layers,
        ActiveMap: {
          Help: "This is a sample map. It contains a list of simple entries that is used for easy entering of map coordinates by using comma or semicolon separation of entries. Ex 'A1,G4'\r\nYou may also enter detailed entries that include a grid location, name, description and coordinates within the grid.\r\n",
          ScoutedGrids: "",
          SimpleEntries: simpleEntries,
          DetailedEntries: []
        }
      };

      const blob = new Blob([JSON.stringify(json, null, 2)], { type: "application/json" });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = "map_export.json";
      link.click();
    }    function clearMap() {
      if (confirm("This will clear all map data. Are you sure you want to continue?")) {
        try {
          pushUndo(); // Allow undoing clear operation
          initializeGrid();
          rerenderAllCells();
          onMapChange();
          showNotification('Map cleared successfully', 'success');
        } catch (error) {
          console.error('Clear failed:', error);
          showNotification('Failed to clear map', 'error');
        }
      }
    }

    function exportAsPng() {
      const cellSize = 150;
      const gap = 2;
      const gridSize = 9;
      const backgroundSrc = 'background.jpg';
      const legendPadding = 30;
      const legendIconSize = 40;
      const legendTextSize = 22;
      const legendSpacing = 18;
      const legendTitleSize = 26;
      const legendTitle = "Legend";
      const legendItems = iconList.map((icon, idx) => ({
        icon,
        name: iconNames[idx]
      }));

      const legendWidth = legendPadding * 2 + legendIconSize + 10 + 140;
      const legendHeight = legendPadding * 2 + legendTitleSize + legendSpacing +
        legendItems.length * (legendIconSize + legendSpacing);

      const dateHeight = 60;
      const gridWidth = gridSize * (cellSize + gap);
      const gridHeight = gridSize * (cellSize + gap);

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = legendWidth + gridWidth;
      canvas.height = Math.max(gridHeight + dateHeight, legendHeight + dateHeight);

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = src;
        });
      }

      const usedIcons = new Set();
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          gridData[row][col].forEach(icon => usedIcons.add(icon));
        }
      }

      const iconPromises = {};
      iconList.forEach(icon => {
        iconPromises[icon] = loadImage(iconPath + icon);
      });

      Promise.all([
        loadImage(backgroundSrc),
        ...Object.values(iconPromises)
      ]).then(([backgroundImage, ...iconImages]) => {
        const iconMap = {};
        let i = 0;
        for (const icon of iconList) {
          iconMap[icon] = iconImages[i++];
        }

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, dateHeight);

        const now = new Date();
        const dateStr = useLocalTime
          ? now.toLocaleString()
          : now.toUTCString();
        ctx.font = "bold 32px Arial";
        ctx.fillStyle = "#fff";
        ctx.textBaseline = "middle";
        ctx.fillText(dateStr, legendWidth + 20, dateHeight / 2);

        ctx.globalAlpha = 0.4;
        ctx.drawImage(backgroundImage, legendWidth, dateHeight, gridWidth, gridHeight);
        ctx.globalAlpha = 1.0;

        ctx.fillStyle = "rgba(30,30,30,0.85)";
        ctx.fillRect(0, dateHeight, legendWidth, legendHeight);

        ctx.font = `bold ${legendTitleSize}px Arial`;
        ctx.fillStyle = "#fff";
        ctx.textBaseline = "top";
        ctx.fillText(legendTitle, legendPadding, dateHeight + legendPadding);

        let legendY = dateHeight + legendPadding + legendTitleSize + legendSpacing;
        ctx.font = `${legendTextSize}px Arial`;
        for (const item of legendItems) {
          if (iconMap[item.icon]) {
            ctx.drawImage(
              iconMap[item.icon],
              legendPadding,
              legendY,
              legendIconSize,
              legendIconSize
            );
          }
          ctx.fillStyle = "#fff";
          ctx.fillText(
            item.name,
            legendPadding + legendIconSize + 10,
            legendY + (legendIconSize - legendTextSize) / 2
          );
          legendY += legendIconSize + legendSpacing;
        }

        for (let row = 8; row >= 0; row--) {
          for (let col = 0; col < gridSize; col++) {
            const canvasRow = 8 - row;
            const x = legendWidth + col * (cellSize + gap);
            const y = dateHeight + canvasRow * (cellSize + gap);

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, cellSize, cellSize);

            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.textBaseline = "top";
            ctx.fillText(String.fromCharCode(65 + row) + (col + 1), x + 8, y + 8);

            const icons = gridData[row][col];
            const n = icons.length;
            if (n > 0) {
              let iconSize, positions;
              if (n === 1) {
                iconSize = 90;
                positions = [[cellSize / 2, cellSize / 2 + 10]];
              } else if (n === 2) {
                iconSize = 70;
                positions = [
                  [cellSize / 2 - 35, cellSize / 2 + 10],
                  [cellSize / 2 + 35, cellSize / 2 + 10]
                ];
              } else if (n === 3) {
                iconSize = 60;
                positions = [
                  [cellSize / 2, cellSize / 2 - 30],
                  [cellSize / 2 - 38, cellSize / 2 + 32],
                  [cellSize / 2 + 38, cellSize / 2 + 32]
                ];
              } else if (n === 4) {
                iconSize = 54;
                positions = [
                  [cellSize / 2 - 32, cellSize / 2 - 24],
                  [cellSize / 2 + 32, cellSize / 2 - 24],
                  [cellSize / 2 - 32, cellSize / 2 + 32],
                  [cellSize / 2 + 32, cellSize / 2 + 32]
                ];
              } else {
                iconSize = 40;
                positions = [];
                const grid = 3;
                const offset = (cellSize - grid * iconSize) / 2;
                for (let i = 0; i < Math.min(n, 9); i++) {
                  const gx = i % 3;
                  const gy = Math.floor(i / 3);
                  positions.push([
                    offset + gx * iconSize + iconSize / 2,
                    30 + offset + gy * iconSize + iconSize / 2
                  ]);
                }
              }
              for (let i = 0; i < Math.min(n, 9); i++) {
                const icon = icons[i];
                if (icon && iconMap[icon]) {
                  ctx.drawImage(
                    iconMap[icon],
                    x + positions[i][0] - iconSize / 2,
                    y + positions[i][1] - iconSize / 2,
                    iconSize,
                    iconSize
                  );
                }
              }
            }

            if (!exploredGrid[row][col]) {
              ctx.fillStyle = "rgba(30,30,30,0.55)";
              ctx.fillRect(x, y, cellSize, cellSize);
            } else {
              ctx.fillStyle = "rgba(255,255,255,0.13)";
              ctx.fillRect(x, y, cellSize, cellSize);
            }
          }
        }

        // Signature at top right, same line as date
        loadImage('fwb.png').then(fwbImg => {
          const sigHeight = 44;
          const sigMargin = 18;
          const sigY = (dateHeight - sigHeight) / 2;
          const sigText = "Provided by Fremen with Benefits";
          ctx.font = "bold 24px Arial";
          const textWidth = ctx.measureText(sigText).width;
          const sigX = canvas.width - sigMargin - sigHeight - 12 - textWidth;

          ctx.save();
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = "#222";
          ctx.fillRect(sigX - 16, sigY - 8, textWidth + sigHeight + 44, sigHeight + 16);
          ctx.globalAlpha = 1.0;

          ctx.drawImage(fwbImg, sigX, sigY, sigHeight, sigHeight);

          ctx.font = "bold 24px Arial";
          ctx.fillStyle = "#ffe066";
          ctx.textBaseline = "middle";
          ctx.fillText(sigText, sigX + sigHeight + 12, sigY + sigHeight / 2);

          ctx.restore();

          const link = document.createElement('a');
          link.download = 'grid.png';
          link.href = canvas.toDataURL();
          link.click();
        });
      });
    }

    function makeCellsDroppable() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.addEventListener('dragover', function (e) {
          e.preventDefault();
        });
        cell.addEventListener('drop', function (e) {
          e.preventDefault();
          const icon = e.dataTransfer.getData('text/plain');
          const row = this.getAttribute('data-row');
          const col = this.getAttribute('data-col');
          if (icon && gridData[row][col].indexOf(icon) === -1) {
            gridData[row][col].push(icon);
            renderCellIcons(this, gridData[row][col]);
          }
        });
      });
    }

    function rerenderAllCells() {
      const cells = document.querySelectorAll('.cell');
      let idx = 0;
      for (let row = 8; row >= 0; row--) {
        for (let col = 0; col < 9; col++) {
          renderCellIcons(cells[idx++], gridData[row][col]);
        }
      }
      makeCellsDroppable();
    }

    document.getElementById('confirmSelectionButton').onclick = function() {
      closeIconPicker();
    };

    function exploreAllCells() {
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          exploredGrid[row][col] = true;
        }
      }
      rerenderAllCells();
      onMapChange();
    }

    function updateStormTimer() {
      const timerDiv = document.getElementById('stormTimer');
      const now = new Date();

      const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);
      let next = new Date(Date.UTC(utcNow.getUTCFullYear(), utcNow.getUTCMonth(), utcNow.getUTCDate(), 4, 0, 0, 0));
      const day = utcNow.getUTCDay();
      if (day > 2 || (day === 2 && utcNow.getUTCHours() >= 4)) {
        next.setUTCDate(next.getUTCDate() + ((9 - day) % 7));
      } else if (day < 2 || (day === 2 && utcNow.getUTCHours() < 4)) {
        next.setUTCDate(next.getUTCDate() + ((2 - day + 7) % 7));
      }

      const diffMs = next.getTime() - utcNow.getTime();
      if (diffMs <= 0) {
        timerDiv.textContent = "Next Coriolis Storm: calculating...";
        return;
      }
      const diffSec = Math.floor(diffMs / 1000);
      const days = Math.floor(diffSec / 86400);
      const hours = Math.floor((diffSec % 86400) / 3600);
      const mins = Math.floor((diffSec % 3600) / 60);
      const secs = diffSec % 60;

      timerDiv.textContent =
        `Next Coriolis Storm: ${days}d ${hours}h ${mins}m ${secs}s (Tuesday 04:00 UTC)`;
    }

    // --- Time Mode Toggle (reverse logic: checked = UTC, unchecked = Local) ---
    document.getElementById('useLocalTime').addEventListener('change', function() {
      useLocalTime = !this.checked;
      updateTimeToggleHighlight();
    });
    // Set initial state: checked = UTC, unchecked = Local
    useLocalTime = !document.getElementById('useLocalTime').checked;
    updateTimeToggleHighlight();

    function updateTimeToggleHighlight() {
      document.getElementById('timeModeLabel').style.fontWeight = useLocalTime ? 'bold' : 'normal';
      document.getElementById('timeModeLabel').style.opacity = useLocalTime ? '1' : '0.5';
      document.getElementById('utcModeLabel').style.fontWeight = useLocalTime ? 'normal' : 'bold';
      document.getElementById('utcModeLabel').style.opacity = useLocalTime ? '0.5' : '1';
      // Visually update the switch to match logic
      document.getElementById('useLocalTime').checked = !useLocalTime;
    }    function autoSaveMap() {
      try {
        const saveData = { gridData, exploredGrid };
        localStorage.setItem('dd_map_autosave', JSON.stringify(saveData));
      } catch (error) {
        console.warn('Auto-save failed:', error);
        // Could implement fallback save mechanism here
      }
    }

    function autoLoadMap() {
      const saveData = localStorage.getItem('dd_map_autosave');
      if (!saveData) return;
      try {
        const parsed = JSON.parse(saveData);
        if (parsed && parsed.gridData && parsed.exploredGrid) {
          validateGridData(parsed.gridData);
          validateExploredGrid(parsed.exploredGrid);
          gridData = parsed.gridData;
          exploredGrid = parsed.exploredGrid;
          rerenderAllCells();
        }
      } catch (error) {
        console.warn('Auto-load failed:', error);
        localStorage.removeItem('dd_map_autosave'); // Clear corrupted data
      }
    }

    function onMapChange() {
      debouncedAutoSave();
    }

    const _oldRenderCellIcons = renderCellIcons;
    renderCellIcons = function(cell, icons) {
      _oldRenderCellIcons(cell, icons);
      onMapChange();
    };

    const _oldClearMap = clearMap;
    clearMap = function() {
      _oldClearMap();
      onMapChange();
    };

    const _oldExploreAllCells = exploreAllCells;
    exploreAllCells = function() {
      _oldExploreAllCells();
      onMapChange();
    };

    setInterval(debouncedAutoSave, 30000);
    setInterval(cleanupMemory, 60000); // Periodically clean up memory

    // Data validation utilities
    function validateGridData(data) {
      if (!Array.isArray(data) || data.length !== 9) {
        throw new Error('Invalid grid data: must be 9x9 array');
      }
      
      for (let row = 0; row < 9; row++) {
        if (!Array.isArray(data[row]) || data[row].length !== 9) {
          throw new Error(`Invalid grid data: row ${row} must be array of length 9`);
        }
        
        for (let col = 0; col < 9; col++) {
          if (!Array.isArray(data[row][col])) {
            throw new Error(`Invalid grid data: cell [${row}][${col}] must be array`);
          }
          
          // Validate icon names
          data[row][col].forEach((icon, idx) => {
            if (typeof icon !== 'string' || !iconList.includes(icon)) {
              console.warn(`Invalid icon at [${row}][${col}][${idx}]: ${icon}`);
              // Remove invalid icon
              data[row][col].splice(idx, 1);
            }
          });
        }
      }
      
      return true;
    }

    function validateExploredGrid(data) {
      if (!Array.isArray(data) || data.length !== 9) {
        throw new Error('Invalid explored grid: must be 9x9 array');
      }
      
      for (let row = 0; row < 9; row++) {
        if (!Array.isArray(data[row]) || data[row].length !== 9) {
          throw new Error(`Invalid explored grid: row ${row} must be array of length 9`);
        }
        
        for (let col = 0; col < 9; col++) {
          if (typeof data[row][col] !== 'boolean') {
            console.warn(`Invalid explored state at [${row}][${col}], converting to boolean`);
            data[row][col] = Boolean(data[row][col]);
          }
        }
      }
      
      return true;
    }

    // Enhanced import function with validation
    function importMapDataSafe(data) {
      try {
        if (!data || typeof data !== 'object') {
          throw new Error('Invalid import data: must be object');
        }
        
        if (!data.gridData || !data.exploredGrid) {
          throw new Error('Invalid import data: missing gridData or exploredGrid');
        }
        
        // Validate data before importing
        validateGridData(data.gridData);
        validateExploredGrid(data.exploredGrid);
        
        // Create backup before importing
        pushUndo();
        
        gridData = data.gridData;
        exploredGrid = data.exploredGrid;
        rerenderAllCells();
        onMapChange();
        
        return { success: true, message: 'Map imported successfully!' };
      } catch (error) {
        console.error('Import failed:', error);
        return { success: false, message: `Import failed: ${error.message}` };
      }
    }

    function initializeApp() {
      renderLegendSafe();
      initializeGrid();
      populateIconPicker();
      rerenderAllCells();
      updateTimeToggleHighlight();
      updateStormTimer();
      setInterval(updateStormTimer, 1000);
      window.addEventListener('resize', throttledResize);
    }

    initializeApp();

    document.getElementById('clearButton').onclick = clearMap;
    document.getElementById('exportPngButton').onclick = exportAsPng;
    document.getElementById('exploreAllButton').onclick = exploreAllCells;
    document.getElementById('undoButton').onclick = undo;
    document.getElementById('redoButton').onclick = redo;

    document.getElementById('legendToggleBtn').onclick = function() {
      const legend = document.getElementById('legendPanel');
      const icon = document.getElementById('legendToggleIcon');
      legend.classList.toggle('collapsed');
      icon.textContent = legend.classList.contains('collapsed') ? '►' : '▼';
    };

    document.getElementById('legendToggleBtn').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.click();
      }
    });

    ['exportPngButton','exploreAllButton','clearButton'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.title = el.textContent;
        el.setAttribute('aria-label', el.textContent);
        el.setAttribute('tabindex', '0');
      }
    });    // --- High Contrast Mode ---
    const highContrastBtn = document.getElementById('highContrastBtn');
    highContrastBtn.addEventListener('click', function() {
      const enabled = document.body.classList.toggle('high-contrast');
      this.setAttribute('aria-pressed', enabled ? 'true' : 'false');
      localStorage.setItem('dd_map_high_contrast', enabled ? '1' : '0');
      showNotification(`High contrast mode ${enabled ? 'enabled' : 'disabled'}`, 'info');
    });

    gridContainer.addEventListener('click', function(e) {
      if (e.target === gridContainer) clearSelection();
    });    window.addEventListener('DOMContentLoaded', function() {
      autoLoadMapEnhanced();
      if (localStorage.getItem('dd_map_high_contrast') === '1') {
        document.body.classList.add('high-contrast');
        highContrastBtn.setAttribute('aria-pressed', 'true');
      }
    });// --- Export as JSON ---
    document.getElementById('exportJsonButton').onclick = function() {
      try {
        const data = { gridData, exploredGrid };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'dune_map.json';
        link.click();
        showNotification('Map exported successfully!', 'success');
      } catch (error) {
        console.error('Export failed:', error);
        showNotification('Failed to export map', 'error');
      }
    };

    // --- Import from JSON (file input) ---
    document.getElementById('importJsonButton').onclick = function() {
      document.getElementById('importJsonInput').click();
    };    document.getElementById('importJsonInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const indicator = showProgressIndicator('Importing map...');
      const reader = new FileReader();
      
      reader.onload = function(evt) {
        try {
          const data = JSON.parse(evt.target.result);
          const result = importMapDataSafe(data);
          hideProgressIndicator();
          
          if (result.success) {
            showNotification(result.message, 'success');
          } else {
            showNotification(result.message, 'error');
          }
        } catch (error) {
          hideProgressIndicator();
          console.error('Import failed:', error);
          showNotification('Invalid JSON file format', 'error');
        }
      };
      
      reader.onerror = function() {
        hideProgressIndicator();
        showNotification('Failed to read file', 'error');
      };
      
      reader.readAsText(file);
    });    // --- Import from JSON (drag-and-drop) ---
    document.body.addEventListener('dragover', function(e) {
      e.preventDefault();
    });
    document.body.addEventListener('drop', function(e) {
      e.preventDefault();
      if (e.dataTransfer.files.length) {
        const file = e.dataTransfer.files[0];
        if (file.type === 'application/json' || file.name.endsWith('.json')) {
          const indicator = showProgressIndicator('Importing dropped file...');
          const reader = new FileReader();
          
          reader.onload = function(evt) {
            try {
              const data = JSON.parse(evt.target.result);
              const result = importMapDataSafe(data);
              hideProgressIndicator();
              
              if (result.success) {
                showNotification(result.message, 'success');
              } else {
                showNotification(result.message, 'error');
              }
            } catch (error) {
              hideProgressIndicator();
              console.error('Import failed:', error);
              showNotification('Invalid JSON file format', 'error');
            }
          };
          
          reader.onerror = function() {
            hideProgressIndicator();
            showNotification('Failed to read file', 'error');
          };
          
          reader.readAsText(file);
        } else {
          showNotification('Please drop a JSON file', 'warning');
        }
      }
    });

    // --- ARIA roles and keyboard navigation for legend and grid ---
    const legendIcons = document.getElementById('legendIcons');
    legendIcons.addEventListener('keydown', function(e) {
      const items = Array.from(legendIcons.querySelectorAll('.legend-item'));
      const idx = items.indexOf(document.activeElement);
      if (e.key === 'ArrowDown' && idx < items.length - 1) {
        items[idx + 1].focus();
        e.preventDefault();
      } else if (e.key === 'ArrowUp' && idx > 0) {
        items[idx - 1].focus();
        e.preventDefault();
      }
    });

    const gridEl = document.getElementById('gridContainer');
    gridEl.addEventListener('keydown', function(e) {
      const cells = Array.from(gridEl.querySelectorAll('.cell'));
      const idx = cells.indexOf(document.activeElement);
      if (idx === -1) return;
      let nextIdx = idx;
      if (e.key === 'ArrowRight' && (idx + 1) % 9 !== 0) nextIdx++;
      else if (e.key === 'ArrowLeft' && idx % 9 !== 0) nextIdx--;
      else if (e.key === 'ArrowDown' && idx + 9 < 81) nextIdx += 9;
      else if (e.key === 'ArrowUp' && idx - 9 >= 0) nextIdx -= 9;
      if (nextIdx !== idx) {
        cells[nextIdx].focus();
        e.preventDefault();
      }
    });

    // --- Versioning ---
    function getVersionList() {
      const versions = JSON.parse(localStorage.getItem('dd_map_versions') || '[]');
      return versions;
    }    function saveVersion() {
      const name = prompt('Enter a name for this version:');
      if (!name) return;
      
      try {
        const versions = getVersionList();
        const timestamp = new Date().toISOString();
        versions.push({ name, timestamp, data: { gridData, exploredGrid } });
        localStorage.setItem('dd_map_versions', JSON.stringify(versions));
        showNotification('Map version saved successfully!', 'success');
      } catch (error) {
        console.error('Save failed:', error);
        showNotification('Failed to save map version', 'error');
      }
    }    function loadVersion() {
      const versions = getVersionList();
      if (!versions.length) {
        showNotification('No saved map versions found', 'warning');
        return;
      }
      
      let msg = 'Select a version to load:\n';
      versions.forEach((v, i) => {
        msg += `${i + 1}: ${v.name} (${v.timestamp})\n`;
      });
      
      const idx = parseInt(prompt(msg)) - 1;
      if (isNaN(idx) || idx < 0 || idx >= versions.length) return;
      
      try {
        const version = versions[idx];
        const result = importMapDataSafe(version.data);
        if (result.success) {
          showNotification('Map version loaded successfully!', 'success');
        } else {
          showNotification(result.message, 'error');
        }
      } catch (error) {
        console.error('Load failed:', error);
        showNotification('Failed to load map version', 'error');
      }
    }
    document.getElementById('saveVersionButton').onclick = saveVersion;
    document.getElementById('loadVersionButton').onclick = loadVersion;
    document.getElementById('saveVersionButton').textContent = 'Save Map';
    document.getElementById('loadVersionButton').textContent = 'Load Map';    // --- Shareable Link ---
    function getShareableLink() {
      try {
        const data = { gridData, exploredGrid };
        const encoded = encodeURIComponent(btoa(unescape(encodeURIComponent(JSON.stringify(data)))));
        const url = `${location.origin}${location.pathname}?map=${encoded}`;
        
        // Try to copy to clipboard if available
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(url).then(() => {
            showNotification('Shareable link copied to clipboard!', 'success');
          }).catch(() => {
            // Fallback to prompt
            prompt('Copy this link to share your map:', url);
          });
        } else {
          // Fallback to prompt
          prompt('Copy this link to share your map:', url);
        }
      } catch (error) {
        console.error('Failed to generate shareable link:', error);
        showNotification('Failed to generate shareable link', 'error');
      }
    }
    document.getElementById('shareLinkButton').onclick = getShareableLink;    // --- Load from shareable link ---
    (function loadFromUrl() {
      const params = new URLSearchParams(location.search);
      if (params.has('map')) {
        try {
          const decoded = decodeURIComponent(params.get('map'));
          const json = JSON.parse(decodeURIComponent(escape(atob(decoded))));
          const result = importMapDataSafe(json);
          if (result.success) {
            showNotification('Map loaded from shareable link!', 'success');
            // Clean URL after loading
            const newUrl = location.origin + location.pathname;
            window.history.replaceState({}, document.title, newUrl);
          } else {
            showNotification(result.message, 'error');
          }
        } catch (error) {
          console.error('Failed to load from link:', error);
          showNotification('Invalid or corrupted shareable link', 'error');
        }
      }
    })();    // --- Polish: Add tooltips to all controls ---
    const tooltipMappings = {
      'undoButton': 'Undo (Ctrl+Z)',
      'redoButton': 'Redo (Ctrl+Y)',
      'exportPngButton': 'Export as PNG',
      'exportJsonButton': 'Export as JSON (Ctrl+E)',
      'importJsonButton': 'Import from JSON (Ctrl+I)',
      'saveVersionButton': 'Save Map Version (Ctrl+S)',
      'loadVersionButton': 'Load Map Version (Ctrl+O)',
      'shareLinkButton': 'Get Shareable Link',
      'highContrastBtn': 'Toggle High Contrast Mode',
      'clearButton': 'Clear Map (Delete selected)',
      'exploreAllButton': 'Mark All Cells as Explored'
    };

    Object.entries(tooltipMappings).forEach(([id, tooltip]) => {
      const el = document.getElementById(id);
      if (el) {
        el.title = tooltip;
        el.setAttribute('aria-label', tooltip);
        el.setAttribute('tabindex', '0');
      }
    });

    // Status notification system
    function showNotification(message, type = 'info', duration = 3000) {
      // Remove existing notifications
      const existing = document.querySelector('.notification-toast');
      if (existing) existing.remove();
      
      const notification = document.createElement('div');
      notification.className = 'notification-toast';
      notification.textContent = message;
      
      // Style based on type
      const styles = {
        info: { background: '#2196F3', color: '#fff' },
        success: { background: '#4CAF50', color: '#fff' },
        warning: { background: '#FF9800', color: '#fff' },
        error: { background: '#f44336', color: '#fff' }
      };
      
      Object.assign(notification.style, {
        position: 'fixed',
        top: '20px',
        right: '20px',
        padding: '12px 20px',
        borderRadius: '4px',
        fontWeight: 'bold',
        fontSize: '14px',
        zIndex: '10000',
        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
        transform: 'translateX(100%)',
        transition: 'transform 0.3s ease-in-out',
        maxWidth: '300px',
        wordWrap: 'break-word',
        ...styles[type]
      });
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 10);
      
      // Auto remove
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => notification.remove(), 300);
      }, duration);
    }

    // Progress indicator for long operations
    function showProgressIndicator(text = 'Processing...') {
      const indicator = document.createElement('div');
      indicator.id = 'progress-indicator';
      indicator.innerHTML = `
        <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 9999;">
          <div style="background: #fff; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <div style="width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #ffe066; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px;"></div>
            <div style="color: #333; font-weight: bold;">${text}</div>
          </div>
        </div>
      `;
      
      // Add CSS animation if not exists
      if (!document.querySelector('#spinner-style')) {
        const style = document.createElement('style');
        style.id = 'spinner-style';
        style.textContent = '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
        document.head.appendChild(style);
      }
      
      document.body.appendChild(indicator);
      return indicator;
    }

    function hideProgressIndicator() {
      const indicator = document.getElementById('progress-indicator');
      if (indicator) indicator.remove();
    }

    // Enhanced keyboard shortcuts and accessibility
    document.addEventListener('keydown', function(e) {
      // Existing shortcuts
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) {
        e.preventDefault();
        redo();
      }
      // New shortcuts
      else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveVersion();
      } else if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
        e.preventDefault();
        loadVersion();
      } else if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
        e.preventDefault();
        document.getElementById('exportJsonButton').click();
      } else if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
        e.preventDefault();
        document.getElementById('importJsonButton').click();
      } else if (e.key === 'Delete' && selectedCells.size > 0) {
        e.preventDefault();
        clearSelectedCells();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        clearSelection();
        closeIconPicker();
      }
    });

    // Clear icons from selected cells
    function clearSelectedCells() {
      if (selectedCells.size === 0) return;
      
      pushUndo();
      let cleared = false;
      
      selectedCells.forEach(key => {
        const [row, col] = key.split(',');
        if (gridData[row][col].length > 0) {
          gridData[row][col] = [];
          cleared = true;
        }
      });
      
      if (cleared) {
        rerenderAllCells();
        renderSelection();
        showNotification(`Cleared ${selectedCells.size} cell(s)`, 'success');
      }
    }

    // Enhanced error handling for PNG export
    const originalExportAsPng = exportAsPng;
    exportAsPng = function() {
      try {
        const indicator = showProgressIndicator('Generating PNG export...');
        
        // Use setTimeout to allow UI to update before heavy processing
        setTimeout(() => {
          try {
            originalExportAsPng();
            hideProgressIndicator();
            showNotification('PNG exported successfully!', 'success');
          } catch (error) {
            hideProgressIndicator();
            console.error('PNG export failed:', error);
            showNotification('Failed to export PNG. Please try again.', 'error');
          }
        }, 10);
      } catch (error) {
        console.error('PNG export initialization failed:', error);
        showNotification('Failed to start PNG export', 'error');
      }
    };

    // Auto-save enhancement with better error handling
    function autoSaveMapEnhanced() {
      try {
        const saveData = { 
          gridData, 
          exploredGrid,
          version: '1.0',
          timestamp: Date.now()
        };
        const serialized = JSON.stringify(saveData);
        
        // Check if data is too large for localStorage
        if (serialized.length > 4.5 * 1024 * 1024) { // 4.5MB limit (conservative)
          console.warn('Map data too large for auto-save, skipping...');
          return;
        }
        
        localStorage.setItem('dd_map_autosave', serialized);
        
        // Also save a backup
        localStorage.setItem('dd_map_autosave_backup', serialized);
      } catch (error) {
        console.warn('Auto-save failed:', error);
        
        // Try to clear some space and retry once
        try {
          localStorage.removeItem('dd_map_autosave_backup');
          localStorage.setItem('dd_map_autosave', JSON.stringify({ gridData, exploredGrid }));
        } catch (retryError) {
          console.error('Auto-save retry failed:', retryError);
        }
      }
    }

    // Enhanced auto-load with recovery options
    function autoLoadMapEnhanced() {
      let saveData = localStorage.getItem('dd_map_autosave');
      
      if (!saveData) {
        // Try backup if main save is missing
        saveData = localStorage.getItem('dd_map_autosave_backup');
        if (saveData) {
          console.log('Loading from backup auto-save');
        }
      }
      
      if (!saveData) return;
      
      try {
        const parsed = JSON.parse(saveData);
        
        // Handle different save formats
        const data = parsed.gridData ? parsed : { gridData: parsed, exploredGrid: parsed.exploredGrid || [] };
        
        if (data && data.gridData && data.exploredGrid) {
          validateGridData(data.gridData);
          validateExploredGrid(data.exploredGrid);
          gridData = data.gridData;
          exploredGrid = data.exploredGrid;
          rerenderAllCells();
          console.log('Auto-loaded previous session');
        }
      } catch (error) {
        console.warn('Auto-load failed:', error);
        
        // Try backup if main save is corrupted
        const backupData = localStorage.getItem('dd_map_autosave_backup');
        if (backupData && backupData !== saveData) {
          try {
            const parsed = JSON.parse(backupData);
            const data = parsed.gridData ? parsed : { gridData: parsed, exploredGrid: parsed.exploredGrid || [] };
            
            if (data && data.gridData && data.exploredGrid) {
              validateGridData(data.gridData);
              validateExploredGrid(data.exploredGrid);
              gridData = data.gridData;
              exploredGrid = data.exploredGrid;
              rerenderAllCells();
              console.log('Recovered from backup auto-save');
              showNotification('Recovered previous session from backup', 'info');
            }
          } catch (backupError) {
            console.error('Backup recovery failed:', backupError);
            localStorage.removeItem('dd_map_autosave');
            localStorage.removeItem('dd_map_autosave_backup');
          }
        } else {
          localStorage.removeItem('dd_map_autosave');
        }
      }
    }

    // Replace the auto-save functions
    autoSaveMap = autoSaveMapEnhanced;
    autoLoadMap = autoLoadMapEnhanced;

    // Performance monitoring for large operations
    function measurePerformance(label, fn) {
      const start = performance.now();
      const result = fn();
      const end = performance.now();
      
      if (end - start > 100) { // Log operations taking more than 100ms
        console.log(`Performance: ${label} took ${(end - start).toFixed(2)}ms`);
      }
      
      return result;
    }

    // Enhanced initialization with error recovery
    function initializeAppEnhanced() {
      try {
        measurePerformance('Legend rendering', () => renderLegendSafe());
        measurePerformance('Grid initialization', () => initializeGrid());
        measurePerformance('Icon picker population', () => populateIconPicker());
        measurePerformance('Cell re-rendering', () => rerenderAllCells());
        
        updateTimeToggleHighlight();
        updateStormTimer();
        setInterval(updateStormTimer, 1000);
        window.addEventListener('resize', throttledResize);
        
        // Add visibility change handler for better resource management
        document.addEventListener('visibilitychange', function() {
          if (document.hidden) {
            // Page is hidden, reduce resource usage
            console.log('Page hidden, reducing timer frequency');
          } else {
            // Page is visible, resume normal operation
            console.log('Page visible, resuming normal operation');
            updateStormTimer();
          }
        });
        
        console.log('Application initialized successfully');
      } catch (error) {
        console.error('Initialization failed:', error);
        showNotification('Application initialization failed. Please refresh the page.', 'error');
      }
    }

    // Replace initialization
    initializeApp = initializeAppEnhanced;
  </script>
  <div style="margin-top:40px; text-align:center;">
    <a href="https://awakening.wiki/Fremen_with_Benefits" target="_blank" style="text-decoration:none; color:inherit;">
      <img src="fwb.png" alt="Fremen with Benefits" style="max-width:220px; width:100%; border-radius:12px; box-shadow:0 2px 16px #222; margin-bottom:10px;">
      <div style="font-family:Arial,sans-serif; font-size:1.2em; color:#ffe066; font-weight:bold;">
        Created by Fremen with Benefits
      </div>
    </a>
  </div>
  <div style="margin-top:18px; text-align:center;">
    <span style="color:#bbb; font-size:0.95em; background:rgba(30,30,30,0.7); padding:6px 18px; border-radius:8px; display:inline-block;">
      Disclaimer: All assets and watermarks belong to Funcom, Fremen with Benefits and Xtrophic.
    </span>
  </div>
</body>
</html>