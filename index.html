<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dune Awakening Deep Desert Mapping</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #000;
    }
    h1 {
      color: #fff;
    }
    p {
      color: #ccc;
    }
    .main-flex {
      display: flex;
      align-items: flex-start;
      gap: 40px;
      justify-content: center; /* Add this line to center the grid and legend horizontally */
    }
    .description-box {
      background: rgba(30,30,30,0.85);
      color: #ffe066;
      border-radius: 10px;
      padding: 18px 18px 18px 18px;
      min-width: 220px;
      max-width: 260px;
      margin-right: 32px;
      font-size: 1em;
      box-shadow: 0 2px 12px #2228;
      align-self: flex-start;
    }
    .description-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 8px;
      letter-spacing: 0.03em;
    }
    .description-content {
      color: #ffe066;
      font-size: 0.98em;
      line-height: 1.6;
    }
    .grid-outer {
      display: flex;
      flex-direction: column;
    }
    .grid-label-row,
    .grid-label-col {
      display: none !important; /* Hide top and side labels */
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(9, 100px);   /* Enlarged cells */
      grid-template-rows: repeat(9, 100px);      /* Enlarged cells */
      gap: 2px;
      background: transparent;
      box-shadow: 0 0 20px #222;
      width: 900px;
      height: 900px;
      z-index: 1;
    }
    .cell {
      border: 1.5px solid #222;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      background-color: transparent;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
      position: relative;
      overflow: hidden;
    }
    .cell:hover {
      background-color: rgba(255,255,255,0.1);
    }
    .cell-label {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 14px;
      color: #fff;
      opacity: 0.7;
      pointer-events: none;
      z-index: 2;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }
    .cell-icons {
      display: flex;
      flex-direction: column; /* Stack rows vertically */
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: flex-start;
      width: 100%;
      height: 100%;
      padding-top: 20px;
      z-index: 1;
    }
    .cell-icon-row {
      display: flex;
      flex-direction: row;
      margin-bottom: 2px;
    }
    .cell-icons img {
      width: 36px;
      height: 36px;
      margin: 2px;
      background: #222;
      border-radius: 4px;
      border: 1px solid #444;
    }
    .legend {
      margin-left: 40px;
      align-self: flex-start;
      color: #fff;
      background: rgba(30,30,30,0.7);
      padding: 10px 10px 18px 10px;
      border-radius: 8px;
      min-width: 140px;
      max-width: 180px;
      font-size: 13px;
      position: static;
      box-sizing: border-box;
    }
    .legend-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 1em;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      font-size: 13px;
    }
    .legend-item img {
      width: 20px;
      height: 20px;
      margin-right: 6px;
      background: #222;
      border-radius: 3px;
      border: 1px solid #444;
    }
    .controls {
      margin-top: 30px;
      text-align: center;
    }
    .cell.unexplored::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(30,30,30,0.55);
      pointer-events: none;
      z-index: 2;
    }
    .cell.explored::after {
      display: none;
    }
    .explored-toggle {
      color: #ffe066 !important;
      text-shadow: 0 0 2px #222, 0 0 8px #ffe066;
    }
    .cell.unexplored .explored-toggle {
      color: #ffe066 !important;
      opacity: 0.7;
    }
    /* Add to your <style> section for even better contrast */
    #useLocalTime {
      accent-color: #ffe066;
    }
    #timeModeLabel {
      color: #fff700;
      font-weight: bold;
    }
    .side-controls {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-top: 24px;
      align-items: stretch;
    }
    .time-toggle {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 4px;
    }
    .switch-label {
      display: flex;
      align-items: center;
      color: #ffe066;
      font-weight: bold;
      font-size: 1.05em;
      gap: 6px;
      min-width: 0; /* Prevents stretching */
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      margin: 0 2px;
      flex-shrink: 0; /* Prevents slider from stretching legend width */
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #444;
      border-radius: 24px;
      transition: background 0.2s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: #ffe066;
      border-radius: 50%;
      transition: transform 0.2s;
      box-shadow: 0 1px 4px #2226;
    }
    .switch input:checked + .slider {
      background: #ffe066;
    }
    .switch input:checked + .slider:before {
      background: #444;
      transform: translateX(20px);
    }
    .pretty-btn {
      background: linear-gradient(90deg, #ffe066 0%, #ffd700 100%);
      color: #222;
      border: none;
      border-radius: 8px;     /* Slightly more rounded */
      padding: 14px 0;        /* Taller buttons */
      font-size: 1.08em;      /* Slightly larger text */
      font-weight: bold;
      letter-spacing: 0.03em; /* Slightly more spacing between letters */
      box-shadow: 0 2px 8px #2224;
      cursor: pointer;
      margin: 0 0 2px 0;      /* Small bottom margin for stacking */
      transition: background 0.2s, color 0.2s, transform 0.1s;
      outline: none;
    }
    .pretty-btn:hover, .pretty-btn:focus {
      background: linear-gradient(90deg, #fff6b0 0%, #ffe066 100%);
      color: #111;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 16px #ffe06655;
    }
    /* Add these styles to your <style> section for the slider switch */
    .switch-label {
      display: flex;
      align-items: center;
      color: #ffe066;
      font-weight: bold;
      font-size: 1.05em;
      gap: 6px;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      margin: 0 2px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #444;
      border-radius: 24px;
      transition: background 0.2s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: #ffe066;
      border-radius: 50%;
      transition: transform 0.2s;
      box-shadow: 0 1px 4px #2226;
    }
    .switch input:checked + .slider {
      background: #ffe066;
    }
    .switch input:checked + .slider:before {
      background: #444;
      transform: translateX(20px);
    }
  </style>
</head>
<body>
  <h1>Dune Awakening Deep Desert Mapping</h1>
  <!-- Add this timer display under your <h1> or wherever you want it visible -->
  <div id="stormTimer" style="color:#ffe066; font-size:1.15em; font-weight:bold; margin-bottom:12px; text-align:center;">
    Next Coriolis Storm: calculating...
  </div>
  <div class="main-flex">
    <!-- Description box on the left -->
    <div class="description-box">
      <div class="description-title">How to Use</div>
      <div class="description-content">
        Click on any cell to set its content, or drag and drop from Legend.<br>
        When youâ€™re finished updating the map, use the export to PNG or JSON button to review your grid or clear to start over.<br>
        You can also save and load the current state of your map locally.<br>
        Lastly, you can set the time to either UTC or your local time.
      </div>
    </div>
    <div class="grid-outer">
      <div style="display:flex;">
        <div class="grid-container" id="gridContainer"></div>
      </div>
    </div>
    <div class="legend">
      <div class="legend-title">Legend</div>
      <div id="legendIcons"></div>
      <div class="side-controls">
        <div class="time-toggle">
          <label class="switch-label">
            <span id="timeModeLabel" style="margin-right:10px;">Local</span>
            <label class="switch">
              <input type="checkbox" id="useLocalTime" checked>
              <span class="slider"></span>
            </label>
            <span id="utcModeLabel" style="margin-left:10px;">UTC</span>
          </label>
        </div>
        <button id="exploreAllButton" class="pretty-btn">Explore All</button>
        <button id="clearButton" class="pretty-btn">Clear Map</button>
      </div>
    </div>
  </div>
  <div class="controls" style="margin-top:30px; text-align:center;">
    <button id="exportPngButton" class="pretty-btn">Export as PNG</button>
    <button id="exportJsonButton" class="pretty-btn">Export as JSON</button>
    <button id="saveLocalButton" class="pretty-btn">Save Map Locally</button>
    <button id="loadLocalButton" class="pretty-btn">Load Map</button>
  </div>

  <!-- Icon Picker Modal -->
  <div id="iconPickerModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1000;">
    <div style="background:#fff; padding:20px; border-radius:8px; max-width:600px;">
      <h3>Select an Icon</h3>
      <div id="iconPickerGrid" style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;"></div>
      <!-- Add Check and Confirm buttons -->
      <div style="margin-top:10px; display:flex; gap:10px;">
        <button id="checkSelectionButton" type="button">Check</button>
        <button id="confirmSelectionButton" type="button">Confirm</button>
        <button onclick="closeIconPicker()">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    let useLocalTime = true;

    const gridContainer = document.getElementById('gridContainer');
    let gridData = [];
    let exploredGrid = []; // New: tracks explored state

    // List of PNG/SVG icon filenames (relative to your project)
    const iconList = [
      "IconAuthorizedBase.png",
      "IconCave.png",
      "IconHomeBase.png",
      "IconPoi.png",
      "IconShipwreck.png",
      "IconShipwreckX2.png",
      "IconSpice.png",
      "IconStravidium.png",
      "IconTestingStation.png",
      "IconTitanium.png"
    ];
    const iconNames = [
      "Authorized Base",
      "Cave",
      "Home Base",
      "POI",
      "Shipwreck",
      "Shipwreck x2",
      "Spice",
      "Stravidium",
      "Testing Station",
      "Titanium"
    ];
    const iconPath = "Icons/";

    let currentCell = null;

    // Make legend icons draggable
    function renderLegend() {
      const legend = document.getElementById('legendIcons');
      legend.innerHTML = '';
      iconList.forEach((icon, idx) => {
        legend.innerHTML += `
          <div class="legend-item" draggable="true" data-icon="${icon}">
            <img src="${iconPath + icon}" alt="${iconNames[idx]}">
            <span>${iconNames[idx]}</span>
          </div>
        `;
      });

      // Add dragstart event to legend icons
      document.querySelectorAll('.legend-item').forEach(item => {
        item.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', this.getAttribute('data-icon'));
        });
      });
    }

    // Initializes a 9x9 grid with reversed letter labels (I at top, A at bottom)
    function initializeGrid() {
      gridContainer.innerHTML = "";
      gridData = [];
      exploredGrid = [];
      for (let row = 8; row >= 0; row--) {
        gridData[row] = [];
        exploredGrid[row] = [];
        for (let col = 0; col < 9; col++) {
          gridData[row][col] = [];
          exploredGrid[row][col] = false; // default unexplored
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-row', row);
          cell.setAttribute('data-col', col);
          cell.innerHTML = "";
          cell.addEventListener('click', handleCellClick);
          gridContainer.appendChild(cell);
        }
      }
      makeCellsDroppable();
    }

    // Show icon picker when a cell is clicked
    function handleCellClick(event) {
      currentCell = event.currentTarget;
      document.getElementById('iconPickerModal').style.display = 'flex';
    }

    // Populate icon picker grid
    function populateIconPicker() {
      const grid = document.getElementById('iconPickerGrid');
      grid.innerHTML = "";
      iconList.forEach(icon => {
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = icon;
        img.style.width = "40px";
        img.style.height = "40px";
        img.style.cursor = "pointer";
        img.title = icon.replace('.png','').replace('Icon','');
        img.onclick = () => selectIcon(icon);
        grid.appendChild(img);
      });
    }

    // When an icon is selected, add/remove it in the cell (toggle)
    function selectIcon(icon) {
      if (currentCell) {
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        const idx = gridData[row][col].indexOf(icon);
        if (idx === -1) {
          gridData[row][col].push(icon); // Add icon
        } else {
          gridData[row][col].splice(idx, 1); // Remove icon if already present
        }
        renderCellIcons(currentCell, gridData[row][col]);
      }
      // Keep picker open for multi-select
    }

    // Helper to render all icons in a cell and show cell label (I at top, A at bottom)
    function renderCellIcons(cell, icons) {
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      const label = String.fromCharCode(65 + parseInt(row)) + (parseInt(col) + 1);

      // If icons are present, auto-explore the cell
      if (icons.length > 0 && !exploredGrid[row][col]) {
        exploredGrid[row][col] = true;
      }

      // Checkmark overlay or "explore" button
      const explored = exploredGrid[row][col];
      let checkHtml = explored
        ? `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark unexplored">&#x2714;</span>`
        : `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark explored">&#x25A2;</span>`;

      let exploredClass = explored ? "explored" : "unexplored";

      let html = `<span class="cell-label">${label}</span>
        <div class="cell-icons" style="display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);width:100%;height:100%;padding-top:20px;">
      `;
      for (let i = 0; i < 9; i++) {
        if (icons[i]) {
          html += `<div style="display:flex;align-items:center;justify-content:center;"><img src="${iconPath + icons[i]}" alt="" draggable="false" style="width:32px;height:32px;"></div>`;
        } else {
          html += `<div></div>`;
        }
      }
      html += `</div>${checkHtml}`;
      cell.innerHTML = html;
      cell.classList.remove("explored", "unexplored");
      cell.classList.add(exploredClass);

      // Add toggle event
      const toggle = cell.querySelector('.explored-toggle');
      if (toggle) {
        toggle.onclick = (e) => {
          e.stopPropagation();
          // Only allow toggling if no icons in cell
          if (gridData[row][col].length === 0) {
            exploredGrid[row][col] = !exploredGrid[row][col];
            renderCellIcons(cell, icons);
          }
        };
        // Style checkmark faded if not explored
        toggle.style.opacity = explored ? "1" : "0.5";
      }
    }

    // Close the icon picker
    function closeIconPicker() {
      document.getElementById('iconPickerModal').style.display = 'none';
      currentCell = null;
    }

    // Outputs the grid data in a coordinate: icons format (from A at top to I at bottom)
    function exportMapData() {
      let output = "Cell\t\tIcons\n";
      output += "-------------------------\n";
      // Loop from row 0 (A/top) to row 8 (I/bottom)
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          if (gridData[row][col].length) {
            const coord = String.fromCharCode(65 + row) + (col + 1);
            const icons = gridData[row][col].map(i => iconNames[iconList.indexOf(i)]).join(", ");
            output += coord + "\t" + icons + "\n";
          }
        }
      }
      if (output === "Cell\t\tIcons\n-------------------------\n") {
        output += "(No icons placed on the map)";
      }
      alert("Exported Map Data:\n" + output);
      console.log("Exported Map Data:\n" + output);
    }

    // Exports the grid data as JSON
    function exportMapDataAsJson() {
      // Define the layers as in your example
      const layers = [
        { Name: "Shipwreck", IconName: "Shipwreck", Description: "Shipwreck" },
        { Name: "TestingStation", IconName: "TestingStation", Description: "Testing station" },
        { Name: "Cave", IconName: "Cave", Description: "Cave" },
        { Name: "Spice", IconName: "Spice", Description: "Spice ring" },
        { Name: "Titanium", IconName: "Titanium", Description: "Titanium" },
        { Name: "Stravidium", IconName: "Stravidium", Description: "Stravidium" },
        { Name: "Poi", IconName: "Poi", Description: "Point of interest" },
        { Name: "AuthorizedBase", IconName: "AuthorizedBase", Description: "Guild base" }
      ];

      // Collect all placed icons as simple entries (e.g. "I1,Shipwreck" for top row, "A1,..." for bottom)
      // FIX: Use same letter order as grid (I at top, A at bottom)
      const simpleEntries = [];
      for (let row = 8; row >= 0; row--) { // I (8) at top, A (0) at bottom
        for (let col = 0; col < 9; col++) {
          gridData[row][col].forEach(icon => {
            let iconName = icon.replace(/^Icon/, '').replace(/\.png$/i, '');
            const coord = String.fromCharCode(65 + row) + (col + 1);
            simpleEntries.push(`${coord},${iconName}`);
          });
        }
      }

      const json = {
        GridSize: 9,
        IconSize: 48,
        GridMapSize: 150,
        IconsFolder: "Icons",
        Layers: layers,
        ActiveMap: {
          Help: "This is a sample map. It contains a list of simple entries that is used for easy entering of map coordinates by using comma or semicolon separation of entries. Ex 'A1,G4'\r\nYou may also enter detailed entries that include a grid location, name, description and coordinates within the grid.\r\n",
          ScoutedGrids: "",
          SimpleEntries: simpleEntries,
          DetailedEntries: []
        }
      };

      // Download as JSON file
      const blob = new Blob([JSON.stringify(json, null, 2)], { type: "application/json" });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = "map_export.json";
      link.click();
    }

    // Clears the grid after confirmation
    function clearMap() {
      if (confirm("This will clear all map data. Are you sure you want to continue?")) {
        initializeGrid();
        rerenderAllCells();
      }
    }

    // Exports the grid as a PNG image (draws SVG icons, from I to A)
    function exportAsPng() {
      const cellSize = 150; // ENLARGED
      const gap = 2;
      const gridSize = 9;
      const backgroundSrc = 'background.jpg';
      const legendPadding = 30;
      const legendIconSize = 40;
      const legendTextSize = 22;
      const legendSpacing = 18;
      const legendTitleSize = 26;
      const legendTitle = "Legend";
      const legendItems = iconList.map((icon, idx) => ({
        icon,
        name: iconNames[idx]
      }));

      // Calculate legend width and height
      const legendWidth = legendPadding * 2 + legendIconSize + 10 + 140;
      const legendHeight = legendPadding * 2 + legendTitleSize + legendSpacing +
        legendItems.length * (legendIconSize + legendSpacing);

      // Add extra space at the top for the date
      const dateHeight = 60;
      const gridWidth = gridSize * (cellSize + gap);
      const gridHeight = gridSize * (cellSize + gap);

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = legendWidth + gridWidth;
      canvas.height = Math.max(gridHeight + dateHeight, legendHeight + dateHeight);

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = src;
        });
      }

      // Gather all unique icons used in the grid
      const usedIcons = new Set();
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          gridData[row][col].forEach(icon => usedIcons.add(icon));
        }
      }

      // Also load all legend icons
      const iconPromises = {};
      iconList.forEach(icon => {
        iconPromises[icon] = loadImage(iconPath + icon);
      });

      Promise.all([
        loadImage(backgroundSrc),
        ...Object.values(iconPromises)
      ]).then(([backgroundImage, ...iconImages]) => {
        const iconMap = {};
        let i = 0;
        for (const icon of iconList) {
          iconMap[icon] = iconImages[i++];
        }

        // Draw black background for date area
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, dateHeight);

        // Draw date at the top
        const now = new Date();
        const dateStr = useLocalTime
          ? now.toLocaleString()
          : now.toUTCString();
        ctx.font = "bold 32px Arial";
        ctx.fillStyle = "#fff";
        ctx.textBaseline = "middle";
        ctx.fillText(dateStr, legendWidth + 20, dateHeight / 2);

        // Draw faded background image for grid area
        ctx.globalAlpha = 0.4;
        ctx.drawImage(backgroundImage, legendWidth, dateHeight, gridWidth, gridHeight);
        ctx.globalAlpha = 1.0;

        // Draw the legend background
        ctx.fillStyle = "rgba(30,30,30,0.85)";
        ctx.fillRect(0, dateHeight, legendWidth, legendHeight);

        // Draw the legend title
        ctx.font = `bold ${legendTitleSize}px Arial`;
        ctx.fillStyle = "#fff";
        ctx.textBaseline = "top";
        ctx.fillText(legendTitle, legendPadding, dateHeight + legendPadding);

        // Draw legend items
        let legendY = dateHeight + legendPadding + legendTitleSize + legendSpacing;
        ctx.font = `${legendTextSize}px Arial`;
        for (const item of legendItems) {
          // Icon
          if (iconMap[item.icon]) {
            ctx.drawImage(
              iconMap[item.icon],
              legendPadding,
              legendY,
              legendIconSize,
              legendIconSize
            );
          }
          // Text
          ctx.fillStyle = "#fff";
          ctx.fillText(
            item.name,
            legendPadding + legendIconSize + 10,
            legendY + (legendIconSize - legendTextSize) / 2
          );
          legendY += legendIconSize + legendSpacing;
        }

        // Draw the grid and icons (row 8 at top, 0 at bottom, so A is bottom, I is top)
        for (let row = 8; row >= 0; row--) {
          for (let col = 0; col < gridSize; col++) {
            const canvasRow = 8 - row; // so row 8 (I) is at top, row 0 (A) is at bottom
            const x = legendWidth + col * (cellSize + gap);
            const y = dateHeight + canvasRow * (cellSize + gap);

            // Draw cell border
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, cellSize, cellSize);

            // Draw cell label using I (top) to A (bottom)
            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.textBaseline = "top";
            ctx.fillText(String.fromCharCode(65 + row) + (col + 1), x + 8, y + 8);

            // Draw up to 9 icons in a 3x3 grid, enlarge and center based on count
            const icons = gridData[row][col];
            const n = icons.length;
            if (n > 0) {
              let iconSize, positions;
              if (n === 1) {
                iconSize = 90;
                positions = [[cellSize / 2, cellSize / 2 + 10]];
              } else if (n === 2) {
                iconSize = 70;
                positions = [
                  [cellSize / 2 - 35, cellSize / 2 + 10],
                  [cellSize / 2 + 35, cellSize / 2 + 10]
                ];
              } else if (n === 3) {
                iconSize = 60;
                positions = [
                  [cellSize / 2, cellSize / 2 - 30],
                  [cellSize / 2 - 38, cellSize / 2 + 32],
                  [cellSize / 2 + 38, cellSize / 2 + 32]
                ];
              } else if (n === 4) {
                iconSize = 54;
                positions = [
                  [cellSize / 2 - 32, cellSize / 2 - 24],
                  [cellSize / 2 + 32, cellSize / 2 - 24],
                  [cellSize / 2 - 32, cellSize / 2 + 32],
                  [cellSize / 2 + 32, cellSize / 2 + 32]
                ];
              } else {
                // Arrange in a 3x3 grid for 5-9 icons
                iconSize = 40;
                positions = [];
                const grid = 3;
                const offset = (cellSize - grid * iconSize) / 2;
                for (let i = 0; i < Math.min(n, 9); i++) {
                  const gx = i % 3;
                  const gy = Math.floor(i / 3);
                  positions.push([
                    offset + gx * iconSize + iconSize / 2,
                    30 + offset + gy * iconSize + iconSize / 2
                  ]);
                }
              }
              for (let i = 0; i < Math.min(n, 9); i++) {
                const icon = icons[i];
                if (icon && iconMap[icon]) {
                  ctx.drawImage(
                    iconMap[icon],
                    x + positions[i][0] - iconSize / 2,
                    y + positions[i][1] - iconSize / 2,
                    iconSize,
                    iconSize
                  );
                }
              }
            }

            // Draw fog overlay if not explored
            if (!exploredGrid[row][col]) {
              ctx.fillStyle = "rgba(30,30,30,0.55)";
              ctx.fillRect(x, y, cellSize, cellSize);
            }
          }
        }

        const link = document.createElement('a');
        link.download = 'grid.png';
        link.href = canvas.toDataURL();
        link.click();
      });
    }

    // Make grid cells droppable
    function makeCellsDroppable() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.addEventListener('dragover', function (e) {
          e.preventDefault();
        });
        cell.addEventListener('drop', function (e) {
          e.preventDefault();
          const icon = e.dataTransfer.getData('text/plain');
          const row = this.getAttribute('data-row');
          const col = this.getAttribute('data-col');
          if (icon && gridData[row][col].indexOf(icon) === -1) {
            gridData[row][col].push(icon);
            renderCellIcons(this, gridData[row][col]);
          }
        });
      });
    }

    // When reloading the grid, re-render icons in each cell (I at top, A at bottom)
    function rerenderAllCells() {
      const cells = document.querySelectorAll('.cell');
      let idx = 0;
      for (let row = 8; row >= 0; row--) {
        for (let col = 0; col < 9; col++) {
          renderCellIcons(cells[idx++], gridData[row][col]);
        }
      }
      makeCellsDroppable();
    }

    // Add check and confirm button logic
    document.getElementById('checkSelectionButton').onclick = function() {
      if (currentCell) {
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        const icons = gridData[row][col];
        if (icons.length === 0) {
          alert("No icons selected for this cell.");
        } else {
          alert(
            "Cell " +
            String.fromCharCode(65 + parseInt(row)) +
            (parseInt(col) + 1) +
            " contains: " +
            icons.map(i => iconNames[iconList.indexOf(i)]).join(", ")
          );
        }
      }
    };
    document.getElementById('confirmSelectionButton').onclick = function() {
      closeIconPicker();
    };

    // Explore All button logic
    document.getElementById('exploreAllButton').onclick = function() {
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          exploredGrid[row][col] = true;
        }
      }
      rerenderAllCells();
    };

    // Save map to localStorage
    document.getElementById('saveLocalButton').onclick = function() {
      const saveData = {
        gridData: gridData,
        exploredGrid: exploredGrid
      };
      localStorage.setItem('dd_map_save', JSON.stringify(saveData));
      alert('Map saved locally!');
    };

    // Load map from localStorage
    document.getElementById('loadLocalButton').onclick = function() {
      const saveData = localStorage.getItem('dd_map_save');
      if (!saveData) {
        alert('No saved map found.');
        return;
      }
      try {
        const parsed = JSON.parse(saveData);
        if (parsed.gridData && parsed.exploredGrid) {
          gridData = parsed.gridData;
          exploredGrid = parsed.exploredGrid;
          rerenderAllCells();
          alert('Map loaded!');
        } else {
          alert('Saved data is invalid.');
        }
      } catch (e) {
        alert('Failed to load map.');
      }
    };

    // Add this function and call it once on page load
    function updateStormTimer() {
      const timerDiv = document.getElementById('stormTimer');
      const now = new Date();

      // Find next Tuesday 04:00 UTC
      const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);
      let next = new Date(Date.UTC(utcNow.getUTCFullYear(), utcNow.getUTCMonth(), utcNow.getUTCDate(), 4, 0, 0, 0));
      // 0=Sun, 1=Mon, 2=Tue, ..., 6=Sat
      const day = utcNow.getUTCDay();
      if (day > 2 || (day === 2 && utcNow.getUTCHours() >= 4)) {
        // If after Tuesday 04:00 UTC, go to next week
        next.setUTCDate(next.getUTCDate() + ((9 - day) % 7));
      } else if (day < 2 || (day === 2 && utcNow.getUTCHours() < 4)) {
        // If before Tuesday, move to this week's Tuesday
        next.setUTCDate(next.getUTCDate() + ((2 - day + 7) % 7));
      }

      // Calculate difference
      const diffMs = next.getTime() - utcNow.getTime();
      if (diffMs <= 0) {
        timerDiv.textContent = "Next Coriolis Storm: calculating...";
        return;
      }
      const diffSec = Math.floor(diffMs / 1000);
      const days = Math.floor(diffSec / 86400);
      const hours = Math.floor((diffSec % 86400) / 3600);
      const mins = Math.floor((diffSec % 3600) / 60);
      const secs = diffSec % 60;

      timerDiv.textContent =
        `Next Coriolis Storm: ${days}d ${hours}h ${mins}m ${secs}s (Tuesday 04:00 UTC)`;
    }

    // Call on load and set interval
    updateStormTimer();
    setInterval(updateStormTimer, 1000);

    // Initialize everything on page load
    renderLegend();
    initializeGrid();
    populateIconPicker();
    rerenderAllCells();

    // Button event listeners
    document.getElementById('clearButton').onclick = clearMap;
    document.getElementById('exportPngButton').onclick = exportAsPng;
    document.getElementById('exportJsonButton').onclick = exportMapDataAsJson;

    // Update the event listener for the slider toggle:
    document.getElementById('useLocalTime').addEventListener('change', function() {
      useLocalTime = this.checked;
      // Always keep left "Local" and right "UTC"
      document.getElementById('timeModeLabel').style.fontWeight = useLocalTime ? 'bold' : 'normal';
      document.getElementById('timeModeLabel').style.opacity = useLocalTime ? '1' : '0.5';
      document.getElementById('utcModeLabel').style.fontWeight = useLocalTime ? 'normal' : 'bold';
      document.getElementById('utcModeLabel').style.opacity = useLocalTime ? '0.5' : '1';
    });
  </script>
  <div style="margin-top:40px; text-align:center;">
    <a href="https://awakening.wiki/Fremen_with_Benefits" target="_blank" style="text-decoration:none; color:inherit;">
      <img src="fwb.png" alt="Fremen with Benefits" style="max-width:220px; width:100%; border-radius:12px; box-shadow:0 2px 16px #222; margin-bottom:10px;">
      <div style="font-family:Arial,sans-serif; font-size:1.2em; color:#ffe066; font-weight:bold;">
        Created by Fremen with Benefits
      </div>
    </a>
  </div>
  <div style="margin-top:18px; text-align:center;">
    <span style="color:#bbb; font-size:0.95em; background:rgba(30,30,30,0.7); padding:6px 18px; border-radius:8px; display:inline-block;">
      Disclaimer: All assets and watermarks belong to Fremen with Benefits and Xtrophic.
    </span>
  </div>
</body>
</html>
``` 
