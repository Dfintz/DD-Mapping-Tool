<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Added mobile viewport -->
  <title>Dune Awakening Deep Desert Mapping</title>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #000;
      display: block;
      flex-direction: unset;
      align-items: unset;
    }
    h1 {
      color: #fff;
      font-size: 2.2em;
      letter-spacing: 0.03em;
      text-align: center;
    }
    .main-flex {
      display: flex;
      align-items: flex-start;
      justify-content: center; /* Center the grid and side panels horizontally */
      gap: 40px;
      width: 100%;
      max-width: none;
    }
    .description-box {
      background: rgba(30,30,30,0.85);
      color: #ffe066;
      border-radius: 10px;
      padding: 18px;
      min-width: 220px;
      max-width: 260px;
      margin-right: 32px;
      font-size: 1em;
      box-shadow: 0 2px 12px #2228;
      align-self: flex-start;
    }
    .description-title {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 8px;
      letter-spacing: 0.03em;
    }
    .description-content {
      color: #ffe066;
      font-size: 0.98em;
      line-height: 1.6;
    }
    .grid-outer {
      display: flex;
      flex-direction: column;
      align-items: center; /* Center the grid horizontally */
    }
    .grid-label-row,
    .grid-label-col {
      display: none !important;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(9, 100px);
      grid-template-rows: repeat(9, 100px);
      gap: 2px;
      background: transparent;
      box-shadow: none;
      width: 900px;
      height: 900px;
      z-index: 1;
      position: relative;
      touch-action: manipulation;
    }
    @media (max-width: 1000px) {
      .grid-container {
        width: 98vw;
        height: 98vw;
        max-width: 98vw;
        max-height: 98vw;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }
    }
    .cell {
      border: 1.5px solid #222;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      background-color: transparent;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s;
      position: relative;
      overflow: hidden;
      touch-action: manipulation;
    }
    .cell:hover, .cell:active {
      background-color: rgba(255,255,255,0.1);
    }
    .cell-label {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 14px;
      color: #fff;
      opacity: 0.7;
      pointer-events: none;
      z-index: 2;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }
    .cell-icons {
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: flex-start;
      width: 100%;
      height: 100%;
      padding-top: 20px;
      z-index: 1;
    }
    .cell-icon-row {
      display: flex;
      flex-direction: row;
      margin-bottom: 2px;
    }
    .cell-icons img {
      width: 36px;
      height: 36px;
      margin: 2px;
      background: #222;
      border-radius: 4px;
      border: 1px solid #444;
      pointer-events: none;
      user-select: none;
    }
    .legend {
      margin-left: 40px;
      align-self: flex-start;
      color: #fff;
      background: rgba(30,30,30,0.7);
      padding: 10px 10px 18px 10px;
      border-radius: 8px;
      min-width: 140px;
      max-width: 180px;
      font-size: 13px;
      position: static;
      box-sizing: border-box;
      width: 180px;
      transition: max-height 0.3s, padding 0.3s;
      overflow: hidden;
    }
    .legend.collapsed {
      max-height: 38px;
      padding-bottom: 0;
    }
    .legend-toggle {
      cursor: pointer;
      color: #ffe066;
      font-size: 1.1em;
      font-weight: bold;
      background: none;
      border: none;
      outline: none;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-toggle:focus {
      outline: 2px solid #ffe066;
    }
    .controls {
      margin-top: 30px;
      display: block;
      justify-content: unset;
      gap: unset;
      flex-wrap: unset;
      width: auto;
    }
    .cell.unexplored::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(30,30,30,0.55);
      pointer-events: none;
      z-index: 2;
    }
    .cell.explored::after {
      display: none;
    }
    .explored-toggle {
      color: #ffe066 !important;
      text-shadow: 0 0 2px #222, 0 0 8px #ffe066;
    }
    .cell.unexplored .explored-toggle {
      color: #ffe066 !important;
      opacity: 0.7;
    }
    #useLocalTime {
      accent-color: #ffe066;
    }
    #timeModeLabel {
      color: #fff700;
      font-weight: bold;
    }
    .side-controls {
      display: flex;
      flex-direction: column;
      gap: 18px;
      margin-top: 24px;
      align-items: center; /* Center the buttons and toggle horizontally */
    }
    .time-toggle {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 4px;
      width: 100%;
    }
    .switch-label {
      display: flex;
      align-items: center;
      color: #ffe066;
      font-weight: bold;
      font-size: 1.05em;
      gap: 6px;
      min-width: 0;
      width: 100%;
      justify-content: space-between;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      margin: 0 2px;
      flex-shrink: 0;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #444;
      border-radius: 24px;
      transition: background 0.2s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: #ffe066;
      border-radius: 50%;
      transition: transform 0.2s;
      box-shadow: 0 1px 4px #2226;
    }
    .switch input:checked + .slider {
      background: #ffe066;
    }
    .switch input:checked + .slider:before {
      background: #444;
      transform: translateX(20px);
    }
    .pretty-btn {
      background: linear-gradient(90deg, #ffe066 0%, #ffd700 100%);
      color: #222;
      border: none;
      border-radius: 22px;
      padding: 14px 32px;
      min-width: 180px;
      font-size: 1.08em;
      font-weight: bold;
      letter-spacing: 0.03em;
      box-shadow: 0 2px 8px #2224;
      cursor: pointer;
      margin: 0 0 10px 0;
      transition: background 0.2s, color 0.2s, transform 0.1s;
      outline: none;
      display: inline-block;
      touch-action: manipulation;
    }
    .pretty-btn:hover, .pretty-btn:focus {
      background: linear-gradient(90deg, #fff6b0 0%, #ffe066 100%);
      color: #111;
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 16px #ffe06655;
    }
    #stormTimer {
      text-align: left;
      width: auto;
      margin-left: 0;
      margin-right: 0;
    }

    /* --- Mobile Mode --- */
    @media (max-width: 1000px) {
      .main-flex {
        flex-direction: column;
        align-items: center;
        gap: 24px;
        max-width: 100vw;
      }
      .description-box,
      .legend {
        margin: 0 auto;
        min-width: 0;
        max-width: 98vw;
        width: 98vw;
      }
      .controls,
      #stormTimer {
        width: 98vw;
        min-width: 0;
        max-width: 98vw;
      }
      .grid-container {
        width: 98vw;
        height: 98vw;
        max-width: 98vw;
        max-height: 98vw;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }
      .cell {
        font-size: 10px;
      }
      .cell-label {
        font-size: 11px;
      }
      .cell-icons img {
        width: 22px;
        height: 22px;
      }
      .legend {
        min-width: 0;
        max-width: 98vw;
        width: 98vw;
        font-size: 12px;
        padding: 8px 4px 12px 4px;
      }
      .legend.collapsed {
        max-height: 38px;
        padding-bottom: 0;
      }
      .legend-item img {
        width: 24px;
        height: 24px;
      }
      .pretty-btn {
        min-width: 120px;
        padding: 10px 10px;
        font-size: 1em;
      }
    }
    [aria-label][tabindex] {
      outline: none;
    }
    [aria-label][tabindex]:focus {
      outline: 2px solid #ffe066;
    }

    .legend-item img {
      width: 36px;
      height: 36px;
    }

    body.high-contrast {
      background: #000 !important;
      color: #fff !important;
    }
    body.high-contrast .legend,
    body.high-contrast .description-box,
    body.high-contrast .side-controls,
    body.high-contrast .controls {
      background: #000 !important;
      color: #fff !important;
      border: 2px solid #fff700 !important;
    }
    body.high-contrast .cell {
      border: 2px solid #fff700 !important;
      background: #111 !important;
      color: #fff !important;
    }
    body.high-contrast .cell-label {
      color: #fff700 !important;
      text-shadow: none !important;
    }
    body.high-contrast .pretty-btn {
      background: #000 !important;
      color: #fff700 !important;
      border: 2px solid #fff700 !important;
      box-shadow: none !important;
    }
    body.high-contrast .pretty-btn:hover, body.high-contrast .pretty-btn:focus {
      background: #222 !important;
      color: #fff !important;
    }
    body.high-contrast .legend-toggle {
      color: #fff700 !important;
    }
    body.high-contrast .explored-toggle {
      color: #fff700 !important;
      text-shadow: none !important;
    }
  </style>
</head>
<body>
  <div style="display:flex; align-items:center; justify-content:center; margin-bottom:10px;">
    <img src="arrakis.png" alt="Arrakis Icon" style="width:54px; height:54px; margin-right:16px; vertical-align:middle;">
    <h1 style="color:#fff; margin:0;">Dune Awakening Deep Desert Mapping</h1>
  </div>
  <div id="stormTimer" style="color:#ffe066; font-size:1.15em; font-weight:bold; margin-bottom:12px; text-align:center;">
    Next Coriolis Storm: calculating...
  </div>
  <div class="main-flex">
    <div class="description-box">
      <div class="description-title">How to Use</div>
      <div class="description-content">
        - Click on any cell to set its content, or drag and drop from Legend.<br>
        - When you’re finished updating the map, use the export to PNG button to download your grid or clear to start over.<br>
        - You can import/export your map as JSON, or save/load named versions.<br>
        - You can set the time to either UTC or your local time for the export to png.
      </div>
    </div>
    <!-- Unified controls row under description box -->
    <div class="main-controls" style="width:100%; display:flex; flex-direction:row; flex-wrap:wrap; justify-content:center; align-items:center; gap:14px; margin-bottom:18px;">
      <button id="saveVersionButton" class="pretty-btn">Save Map</button>
      <button id="loadVersionButton" class="pretty-btn">Load Map</button>
      <button id="exportJsonButton" class="pretty-btn">Export as JSON</button>
      <button id="importJsonButton" class="pretty-btn">Import from JSON</button>
      <input type="file" id="importJsonInput" accept="application/json" style="display:none;" />
      <button id="exportPngButton" class="pretty-btn">Export as PNG</button>
      <button id="shareLinkButton" class="pretty-btn">Get Shareable Link</button>
    </div>
    <div class="grid-outer">
      <div style="display:flex;">
        <div class="grid-container" id="gridContainer" role="grid" aria-label="Map grid"></div>
      </div>
    </div>
    <div class="legend" id="legendPanel">
      <button class="legend-toggle" id="legendToggleBtn" aria-label="Toggle legend" tabindex="0" title="Show/hide legend">
        <span id="legendToggleIcon">▼</span>
        <span class="legend-title">Legend</span>
      </button>
      <div id="legendIcons" role="list" aria-label="Map legend icons"></div>
    </div>
    <div class="side-controls">
      <div class="time-toggle">
        <label class="switch-label">
          <span id="timeModeLabel" style="margin-right:10px;">Local</span>
          <label class="switch">
            <input type="checkbox" id="useLocalTime" checked>
            <span class="slider"></span>
          </label>
          <span id="utcModeLabel" style="margin-left:10px;">UTC</span>
        </label>
      </div>
      <button id="exploreAllButton" class="pretty-btn">Explore All</button>
      <button id="undoButton" class="pretty-btn" title="Undo (Ctrl+Z)">Undo</button>
      <button id="redoButton" class="pretty-btn" title="Redo (Ctrl+Y)">Redo</button>
      <button id="clearButton" class="pretty-btn">Clear Map</button>
      <button id="highContrastBtn" class="pretty-btn" aria-pressed="false" title="Toggle high contrast mode">High Contrast</button>
    </div>
  </div>

  <!-- Icon Picker Modal -->
  <div id="iconPickerModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.15); align-items:center; justify-content:center; z-index:1000;">
    <div style="background:rgba(255,255,255,0.85); padding:20px; border-radius:8px; max-width:600px; box-shadow:0 4px 32px #0008; position:relative;">
      <h3>Select an Icon</h3>
      <div id="iconPickerGrid" style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;"></div>
      <div style="margin-top:10px; display:flex; gap:10px;">
        <button id="confirmSelectionButton" type="button">Confirm</button>
        <button onclick="closeIconPicker()">Cancel</button>
      </div>
      <div id="iconPickerFeedback" style="display:none; position:absolute; top:10px; right:20px; background:#ffe066; color:#222; font-weight:bold; padding:6px 18px; border-radius:8px; box-shadow:0 2px 8px #2224; z-index:10;">Icon placed!</div>
    </div>
  </div>

  <script>
    let useLocalTime = true;
    const gridContainer = document.getElementById('gridContainer');
    let gridData = [];
    let exploredGrid = [];
    let undoStack = [];
    let redoStack = [];
    let selectedCells = new Set();
    let isSelecting = false;

    const iconList = [
      "IconAuthorizedBase.png",
      "IconCave.png",
      "IconHomeBase.png",
      "IconPoi.png",
      "IconShipwreck.png",
      "IconShipwreckX2.png",
      "IconSpice.png",
      "IconStravidium.png",
      "IconTestingStation.png",
      "IconTitanium.png"
    ];
    const iconNames = [
      "Authorized Base",
      "Cave",
      "Home Base",
      "POI",
      "Shipwreck",
      "Shipwreck x2",
      "Spice",
      "Stravidium",
      "Testing Station",
      "Titanium"
    ];
    const iconPath = "Icons/";
    let currentCell = null;

    function pushUndo() {
      undoStack.push({
        gridData: JSON.parse(JSON.stringify(gridData)),
        exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
        selectedCells: Array.from(selectedCells)
      });
      if (undoStack.length > 100) undoStack.shift();
      redoStack = [];
    }

    function undo() {
      if (undoStack.length === 0) return;
      redoStack.push({
        gridData: JSON.parse(JSON.stringify(gridData)),
        exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
        selectedCells: Array.from(selectedCells)
      });
      const prev = undoStack.pop();
      gridData = prev.gridData;
      exploredGrid = prev.exploredGrid;
      selectedCells = new Set(prev.selectedCells);
      rerenderAllCells();
      renderSelection();
    }

    function redo() {
      if (redoStack.length === 0) return;
      undoStack.push({
        gridData: JSON.parse(JSON.stringify(gridData)),
        exploredGrid: JSON.parse(JSON.stringify(exploredGrid)),
        selectedCells: Array.from(selectedCells)
      });
      const next = redoStack.pop();
      gridData = next.gridData;
      exploredGrid = next.exploredGrid;
      selectedCells = new Set(next.selectedCells);
      rerenderAllCells();
      renderSelection();
    }

    function cellKey(row, col) {
      return row + "," + col;
    }

    function renderLegend() {
      const legend = document.getElementById('legendIcons');
      legend.innerHTML = '';
      iconList.forEach((icon, idx) => {
        const div = document.createElement('div');
        div.className = 'legend-item';
        div.setAttribute('draggable', 'true');
        div.setAttribute('data-icon', icon);
        div.setAttribute('tabindex', '0');
        div.setAttribute('aria-label', iconNames[idx] + ' (drag to grid or click to select)');
        div.title = 'Drag to grid or click to select';
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = iconNames[idx];
        img.title = iconNames[idx];
        const span = document.createElement('span');
        span.textContent = iconNames[idx];
        div.appendChild(img);
        div.appendChild(span);
        legend.appendChild(div);
        div.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', this.getAttribute('data-icon'));
        });
        div.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
          }
        });
      });
    }

    function initializeGrid() {
      gridContainer.innerHTML = "";
      gridData = [];
      exploredGrid = [];
      for (let row = 8; row >= 0; row--) {
        gridData[row] = [];
        exploredGrid[row] = [];
        for (let col = 0; col < 9; col++) {
          gridData[row][col] = [];
          exploredGrid[row][col] = false;
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.setAttribute('data-row', row);
          cell.setAttribute('data-col', col);
          cell.setAttribute('tabindex', '0');
          cell.setAttribute('aria-label', `Grid cell ${String.fromCharCode(65+row)}${col+1}`);
          cell.title = `Grid cell ${String.fromCharCode(65+row)}${col+1}`;
          cell.innerHTML = "";
          cell.addEventListener('click', handleCellClick);
          cell.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleCellClick({currentTarget: cell});
            }
          });
          gridContainer.appendChild(cell);
        }
      }
      makeCellsDroppable();
    }

    function handleCellClick(event) {
      const cell = event.currentTarget;
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      if (event.shiftKey) {
        // Multi-select
        const key = cellKey(row, col);
        if (selectedCells.has(key)) {
          selectedCells.delete(key);
        } else {
          selectedCells.add(key);
        }
        renderSelection();
        return;
      }
      if (selectedCells.size > 1) {
        // Batch edit: open icon picker for all selected
        currentCell = null;
        document.getElementById('iconPickerModal').style.display = 'flex';
      } else {
        currentCell = cell;
        document.getElementById('iconPickerModal').style.display = 'flex';
      }
    }

    function renderSelection() {
      document.querySelectorAll('.cell').forEach(cell => {
        const row = cell.getAttribute('data-row');
        const col = cell.getAttribute('data-col');
        const key = cellKey(row, col);
        if (selectedCells.has(key)) {
          cell.style.outline = '3px solid #ffe066';
          cell.style.boxShadow = '0 0 8px #ffe066cc';
        } else {
          cell.style.outline = '';
          cell.style.boxShadow = '';
        }
      });
    }

    function clearSelection() {
      selectedCells.clear();
      renderSelection();
    }

    function populateIconPicker() {
      const grid = document.getElementById('iconPickerGrid');
      grid.innerHTML = "";
      let selectedIcon = null;

      // Determine which icons are present in the current cell or all selected cells
      let presentIcons = new Set();
      if (selectedCells.size > 1) {
        // Multi-cell: collect all icons present in any selected cell
        selectedCells.forEach(key => {
          const [row, col] = key.split(',');
          gridData[row][col].forEach(icon => presentIcons.add(icon));
        });
      } else if (currentCell) {
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        gridData[row][col].forEach(icon => presentIcons.add(icon));
      }

      iconList.forEach(icon => {
        const img = document.createElement('img');
        img.src = iconPath + icon;
        img.alt = icon;
        img.style.width = "24px";
        img.style.height = "24px";
        img.style.cursor = "pointer";
        img.style.border = presentIcons.has(icon) ? "2.5px solid #a259e6" : "2px solid transparent";
        img.style.borderRadius = "6px";
        img.title = icon.replace('.png','').replace('Icon','');
        img.onclick = () => {
          // Remove border from all icons
          Array.from(grid.children).forEach(child => {
            // Only remove border if not present in the cell(s)
            if (!presentIcons.has(child.alt)) {
              child.style.border = "2px solid transparent";
            }
          });
          img.style.border = "2.5px solid #a259e6";
          selectedIcon = icon;
          selectIcon(icon);
        };
        grid.appendChild(img);
      });
    }

    // Batch icon selection for multi-cell
    function selectIcon(icon) {
      let placed = false;
      if (selectedCells.size > 1) {
        pushUndo();
        selectedCells.forEach(key => {
          const [row, col] = key.split(',');
          const idx = gridData[row][col].indexOf(icon);
          if (idx === -1) {
            gridData[row][col].push(icon);
            placed = true;
          } else {
            gridData[row][col].splice(idx, 1);
            placed = true;
          }
        });
        rerenderAllCells();
        renderSelection();
      } else if (currentCell) {
        pushUndo();
        const row = currentCell.getAttribute('data-row');
        const col = currentCell.getAttribute('data-col');
        const idx = gridData[row][col].indexOf(icon);
        if (idx === -1) {
          gridData[row][col].push(icon);
          placed = true;
        } else {
          gridData[row][col].splice(idx, 1);
          placed = true;
        }
        renderCellIcons(currentCell, gridData[row][col]);
      }
      if (placed) {
        showIconPickerFeedback();
      }
    }

    function showIconPickerFeedback() {
      const feedback = document.getElementById('iconPickerFeedback');
      if (!feedback) return;
      feedback.textContent = 'Icon placed!';
      feedback.style.display = 'block';
      feedback.style.opacity = '1';
      setTimeout(() => {
        feedback.style.transition = 'opacity 0.5s';
        feedback.style.opacity = '0';
        setTimeout(() => {
          feedback.style.display = 'none';
          feedback.style.transition = '';
        }, 500);
      }, 600);
    }

    function renderCellIcons(cell, icons) {
      const row = cell.getAttribute('data-row');
      const col = cell.getAttribute('data-col');
      const label = String.fromCharCode(65 + parseInt(row)) + (parseInt(col) + 1);

      if (icons.length > 0 && !exploredGrid[row][col]) {
        exploredGrid[row][col] = true;
      }

      const explored = exploredGrid[row][col];
      let checkHtml = explored
        ? `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark unexplored">&#x2714;</span>`
        : `<span class="explored-toggle" style="position:absolute;top:2px;right:4px;z-index:3;cursor:pointer;font-size:18px;color:#ffe066;text-shadow:0 0 2px #222,0 0 8px #ffe066;" title="Mark explored">&#x25A2;</span>`;

      let exploredClass = explored ? "explored" : "unexplored";

      // Build the cell content safely
      const wrapper = document.createElement('div');
      wrapper.innerHTML = `<span class="cell-label"></span>
        <div class="cell-icons" style="display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);width:100%;height:100%;padding-top:20px;"></div>${checkHtml}`;

      // Set label safely
      wrapper.querySelector('.cell-label').textContent = label;

      // Add icons safely
      const iconsGrid = wrapper.querySelector('.cell-icons');
      for (let i = 0; i < 9; i++) {
        const iconDiv = document.createElement('div');
        iconDiv.style.display = "flex";
        iconDiv.style.alignItems = "center";
        iconDiv.style.justifyContent = "center";
        if (icons[i]) {
          const img = document.createElement('img');
          img.src = iconPath + icons[i];
          img.alt = "";
          img.draggable = false;
          img.style.width = "32px";
          img.style.height = "32px";
          iconDiv.appendChild(img);
        }
        iconsGrid.appendChild(iconDiv);
      }

      // Replace cell content
      cell.innerHTML = '';
      Array.from(wrapper.childNodes).forEach(n => cell.appendChild(n));
      cell.classList.remove("explored", "unexplored");
      cell.classList.add(exploredClass);

      const toggle = cell.querySelector('.explored-toggle');
      if (toggle) {
        toggle.onclick = (e) => {
          e.stopPropagation();
          if (gridData[row][col].length === 0) {
            exploredGrid[row][col] = !exploredGrid[row][col];
            renderCellIcons(cell, icons);
          }
        };
        toggle.style.opacity = explored ? "1" : "0.5";
      }
      onMapChange();
    }

    function closeIconPicker() {
      document.getElementById('iconPickerModal').style.display = 'none';
      currentCell = null;
    }

    function exportMapData() {
      let output = "Cell\t\tIcons\n";
      output += "-------------------------\n";
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          if (gridData[row][col].length) {
            const coord = String.fromCharCode(65 + row) + (col + 1);
            const icons = gridData[row][col].map(i => iconNames[iconList.indexOf(i)]).join(", ");
            output += coord + "\t" + icons + "\n";
          }
        }
      }
      if (output === "Cell\t\tIcons\n-------------------------\n") {
        output += "(No icons placed on the map)";
      }
      alert("Exported Map Data:\n" + output);
      console.log("Exported Map Data:\n" + output);
    }

    function exportMapDataAsJson() {
      const layers = [
        { Name: "Shipwreck", IconName: "Shipwreck", Description: "Shipwreck" },
        { Name: "TestingStation", IconName: "TestingStation", Description: "Testing station" },
        { Name: "Cave", IconName: "Cave", Description: "Cave" },
        { Name: "Spice", IconName: "Spice", Description: "Spice ring" },
        { Name: "Titanium", IconName: "Titanium", Description: "Titanium" },
        { Name: "Stravidium", IconName: "Stravidium", Description: "Stravidium" },
        { Name: "Poi", IconName: "Poi", Description: "Point of interest" },
        { Name: "AuthorizedBase", IconName: "AuthorizedBase", Description: "Guild base" }
      ];

      const simpleEntries = [];
      for (let row = 8; row >= 0; row--) {
        for (let col = 0; col < 9; col++) {
          gridData[row][col].forEach(icon => {
            let iconName = icon.replace(/^Icon/, '').replace(/\.png$/i, '');
            const coord = String.fromCharCode(65 + row) + (col + 1);
            simpleEntries.push(`${coord},${iconName}`);
          });
        }
      }

      const json = {
        GridSize: 9,
        IconSize: 48,
        GridMapSize: 150,
        IconsFolder: "Icons",
        Layers: layers,
        ActiveMap: {
          Help: "This is a sample map. It contains a list of simple entries that is used for easy entering of map coordinates by using comma or semicolon separation of entries. Ex 'A1,G4'\r\nYou may also enter detailed entries that include a grid location, name, description and coordinates within the grid.\r\n",
          ScoutedGrids: "",
          SimpleEntries: simpleEntries,
          DetailedEntries: []
        }
      };

      const blob = new Blob([JSON.stringify(json, null, 2)], { type: "application/json" });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = "map_export.json";
      link.click();
    }

    function clearMap() {
      if (confirm("This will clear all map data. Are you sure you want to continue?")) {
        initializeGrid();
        rerenderAllCells();
        onMapChange();
      }
    }

    function exportAsPng() {
      const cellSize = 150;
      const gap = 2;
      const gridSize = 9;
      const backgroundSrc = 'background.jpg';
      const legendPadding = 30;
      const legendIconSize = 40;
      const legendTextSize = 22;
      const legendSpacing = 18;
      const legendTitleSize = 26;
      const legendTitle = "Legend";
      const legendItems = iconList.map((icon, idx) => ({
        icon,
        name: iconNames[idx]
      }));

      const legendWidth = legendPadding * 2 + legendIconSize + 10 + 140;
      const legendHeight = legendPadding * 2 + legendTitleSize + legendSpacing +
        legendItems.length * (legendIconSize + legendSpacing);

      const dateHeight = 60;
      const gridWidth = gridSize * (cellSize + gap);
      const gridHeight = gridSize * (cellSize + gap);

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = legendWidth + gridWidth;
      canvas.height = Math.max(gridHeight + dateHeight, legendHeight + dateHeight);

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = src;
        });
      }

      const usedIcons = new Set();
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          gridData[row][col].forEach(icon => usedIcons.add(icon));
        }
      }

      const iconPromises = {};
      iconList.forEach(icon => {
        iconPromises[icon] = loadImage(iconPath + icon);
      });

      Promise.all([
        loadImage(backgroundSrc),
        ...Object.values(iconPromises)
      ]).then(([backgroundImage, ...iconImages]) => {
        const iconMap = {};
        let i = 0;
        for (const icon of iconList) {
          iconMap[icon] = iconImages[i++];
        }

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, dateHeight);

        const now = new Date();
        const dateStr = useLocalTime
          ? now.toLocaleString()
          : now.toUTCString();
        ctx.font = "bold 32px Arial";
        ctx.fillStyle = "#fff";
        ctx.textBaseline = "middle";
        ctx.fillText(dateStr, legendWidth + 20, dateHeight / 2);

        ctx.globalAlpha = 0.4;
        ctx.drawImage(backgroundImage, legendWidth, dateHeight, gridWidth, gridHeight);
        ctx.globalAlpha = 1.0;

        ctx.fillStyle = "rgba(30,30,30,0.85)";
        ctx.fillRect(0, dateHeight, legendWidth, legendHeight);

        ctx.font = `bold ${legendTitleSize}px Arial`;
        ctx.fillStyle = "#fff";
        ctx.textBaseline = "top";
        ctx.fillText(legendTitle, legendPadding, dateHeight + legendPadding);

        let legendY = dateHeight + legendPadding + legendTitleSize + legendSpacing;
        ctx.font = `${legendTextSize}px Arial`;
        for (const item of legendItems) {
          if (iconMap[item.icon]) {
            ctx.drawImage(
              iconMap[item.icon],
              legendPadding,
              legendY,
              legendIconSize,
              legendIconSize
            );
          }
          ctx.fillStyle = "#fff";
          ctx.fillText(
            item.name,
            legendPadding + legendIconSize + 10,
            legendY + (legendIconSize - legendTextSize) / 2
          );
          legendY += legendIconSize + legendSpacing;
        }

        for (let row = 8; row >= 0; row--) {
          for (let col = 0; col < gridSize; col++) {
            const canvasRow = 8 - row;
            const x = legendWidth + col * (cellSize + gap);
            const y = dateHeight + canvasRow * (cellSize + gap);

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, cellSize, cellSize);

            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.textBaseline = "top";
            ctx.fillText(String.fromCharCode(65 + row) + (col + 1), x + 8, y + 8);

            const icons = gridData[row][col];
            const n = icons.length;
            if (n > 0) {
              let iconSize, positions;
              if (n === 1) {
                iconSize = 90;
                positions = [[cellSize / 2, cellSize / 2 + 10]];
              } else if (n === 2) {
                iconSize = 70;
                positions = [
                  [cellSize / 2 - 35, cellSize / 2 + 10],
                  [cellSize / 2 + 35, cellSize / 2 + 10]
                ];
              } else if (n === 3) {
                iconSize = 60;
                positions = [
                  [cellSize / 2, cellSize / 2 - 30],
                  [cellSize / 2 - 38, cellSize / 2 + 32],
                  [cellSize / 2 + 38, cellSize / 2 + 32]
                ];
              } else if (n === 4) {
                iconSize = 54;
                positions = [
                  [cellSize / 2 - 32, cellSize / 2 - 24],
                  [cellSize / 2 + 32, cellSize / 2 - 24],
                  [cellSize / 2 - 32, cellSize / 2 + 32],
                  [cellSize / 2 + 32, cellSize / 2 + 32]
                ];
              } else {
                iconSize = 40;
                positions = [];
                const grid = 3;
                const offset = (cellSize - grid * iconSize) / 2;
                for (let i = 0; i < Math.min(n, 9); i++) {
                  const gx = i % 3;
                  const gy = Math.floor(i / 3);
                  positions.push([
                    offset + gx * iconSize + iconSize / 2,
                    30 + offset + gy * iconSize + iconSize / 2
                  ]);
                }
              }
              for (let i = 0; i < Math.min(n, 9); i++) {
                const icon = icons[i];
                if (icon && iconMap[icon]) {
                  ctx.drawImage(
                    iconMap[icon],
                    x + positions[i][0] - iconSize / 2,
                    y + positions[i][1] - iconSize / 2,
                    iconSize,
                    iconSize
                  );
                }
              }
            }

            if (!exploredGrid[row][col]) {
              ctx.fillStyle = "rgba(30,30,30,0.55)";
              ctx.fillRect(x, y, cellSize, cellSize);
            } else {
              ctx.fillStyle = "rgba(255,255,255,0.13)";
              ctx.fillRect(x, y, cellSize, cellSize);
            }
          }
        }

        // Signature at top right, same line as date
        loadImage('fwb.png').then(fwbImg => {
          const sigHeight = 44;
          const sigMargin = 18;
          const sigY = (dateHeight - sigHeight) / 2;
          const sigText = "Provided by Fremen with Benefits";
          ctx.font = "bold 24px Arial";
          const textWidth = ctx.measureText(sigText).width;
          const sigX = canvas.width - sigMargin - sigHeight - 12 - textWidth;

          ctx.save();
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = "#222";
          ctx.fillRect(sigX - 16, sigY - 8, textWidth + sigHeight + 44, sigHeight + 16);
          ctx.globalAlpha = 1.0;

          ctx.drawImage(fwbImg, sigX, sigY, sigHeight, sigHeight);

          ctx.font = "bold 24px Arial";
          ctx.fillStyle = "#ffe066";
          ctx.textBaseline = "middle";
          ctx.fillText(sigText, sigX + sigHeight + 12, sigY + sigHeight / 2);

          ctx.restore();

          const link = document.createElement('a');
          link.download = 'grid.png';
          link.href = canvas.toDataURL();
          link.click();
        });
      });
    }

    function makeCellsDroppable() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.addEventListener('dragover', function (e) {
          e.preventDefault();
        });
        cell.addEventListener('drop', function (e) {
          e.preventDefault();
          const icon = e.dataTransfer.getData('text/plain');
          const row = this.getAttribute('data-row');
          const col = this.getAttribute('data-col');
          if (icon && gridData[row][col].indexOf(icon) === -1) {
            gridData[row][col].push(icon);
            renderCellIcons(this, gridData[row][col]);
          }
        });
      });
    }

    function rerenderAllCells() {
      const cells = document.querySelectorAll('.cell');
      let idx = 0;
      for (let row = 8; row >= 0; row--) {
        for (let col = 0; col < 9; col++) {
          renderCellIcons(cells[idx++], gridData[row][col]);
        }
      }
      makeCellsDroppable();
    }

    document.getElementById('confirmSelectionButton').onclick = function() {
      closeIconPicker();
    };

    function exploreAllCells() {
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          exploredGrid[row][col] = true;
        }
      }
      rerenderAllCells();
      onMapChange();
    }

    function updateStormTimer() {
      const timerDiv = document.getElementById('stormTimer');
      const now = new Date();

      const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);
      let next = new Date(Date.UTC(utcNow.getUTCFullYear(), utcNow.getUTCMonth(), utcNow.getUTCDate(), 4, 0, 0, 0));
      const day = utcNow.getUTCDay();
      if (day > 2 || (day === 2 && utcNow.getUTCHours() >= 4)) {
        next.setUTCDate(next.getUTCDate() + ((9 - day) % 7));
      } else if (day < 2 || (day === 2 && utcNow.getUTCHours() < 4)) {
        next.setUTCDate(next.getUTCDate() + ((2 - day + 7) % 7));
      }

      const diffMs = next.getTime() - utcNow.getTime();
      if (diffMs <= 0) {
        timerDiv.textContent = "Next Coriolis Storm: calculating...";
        return;
      }
      const diffSec = Math.floor(diffMs / 1000);
      const days = Math.floor(diffSec / 86400);
      const hours = Math.floor((diffSec % 86400) / 3600);
      const mins = Math.floor((diffSec % 3600) / 60);
      const secs = diffSec % 60;

      timerDiv.textContent =
        `Next Coriolis Storm: ${days}d ${hours}h ${mins}m ${secs}s (Tuesday 04:00 UTC)`;
    }

    // --- Time Mode Toggle (reverse logic: checked = UTC, unchecked = Local) ---
    document.getElementById('useLocalTime').addEventListener('change', function() {
      useLocalTime = !this.checked;
      updateTimeToggleHighlight();
    });
    // Set initial state: checked = UTC, unchecked = Local
    useLocalTime = !document.getElementById('useLocalTime').checked;
    updateTimeToggleHighlight();

    function updateTimeToggleHighlight() {
      document.getElementById('timeModeLabel').style.fontWeight = useLocalTime ? 'bold' : 'normal';
      document.getElementById('timeModeLabel').style.opacity = useLocalTime ? '1' : '0.5';
      document.getElementById('utcModeLabel').style.fontWeight = useLocalTime ? 'normal' : 'bold';
      document.getElementById('utcModeLabel').style.opacity = useLocalTime ? '0.5' : '1';
      // Visually update the switch to match logic
      document.getElementById('useLocalTime').checked = !useLocalTime;
    }

    function autoSaveMap() {
      const saveData = { gridData, exploredGrid };
      localStorage.setItem('dd_map_autosave', JSON.stringify(saveData));
    }

    function autoLoadMap() {
      const saveData = localStorage.getItem('dd_map_autosave');
      if (!saveData) return;
      try {
        const parsed = JSON.parse(saveData);
        if (parsed.gridData && parsed.exploredGrid) {
          gridData = parsed.gridData;
          exploredGrid = parsed.exploredGrid;
          rerenderAllCells();
        }
      } catch {}
    }

    function onMapChange() {
      autoSaveMap();
    }

    const _oldRenderCellIcons = renderCellIcons;
    renderCellIcons = function(cell, icons) {
      _oldRenderCellIcons(cell, icons);
      onMapChange();
    };

    const _oldClearMap = clearMap;
    clearMap = function() {
      _oldClearMap();
      onMapChange();
    };

    const _oldExploreAllCells = exploreAllCells;
    exploreAllCells = function() {
      _oldExploreAllCells();
      onMapChange();
    };

    setInterval(autoSaveMap, 30000);

    function initializeApp() {
      renderLegend();
      initializeGrid();
      populateIconPicker();
      rerenderAllCells();
      updateTimeToggleHighlight();
      updateStormTimer();
      setInterval(updateStormTimer, 1000);
    }

    initializeApp();

    document.getElementById('clearButton').onclick = clearMap;
    document.getElementById('exportPngButton').onclick = exportAsPng;
    document.getElementById('exploreAllButton').onclick = exploreAllCells;
    document.getElementById('undoButton').onclick = undo;
    document.getElementById('redoButton').onclick = redo;

    document.getElementById('legendToggleBtn').onclick = function() {
      const legend = document.getElementById('legendPanel');
      const icon = document.getElementById('legendToggleIcon');
      legend.classList.toggle('collapsed');
      icon.textContent = legend.classList.contains('collapsed') ? '►' : '▼';
    };

    document.getElementById('legendToggleBtn').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.click();
      }
    });

    ['exportPngButton','exploreAllButton','clearButton'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.title = el.textContent;
        el.setAttribute('aria-label', el.textContent);
        el.setAttribute('tabindex', '0');
      }
    });

    document.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
      } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) {
        e.preventDefault();
        redo();
      }
    });

    gridContainer.addEventListener('click', function(e) {
      if (e.target === gridContainer) clearSelection();
    });

    window.addEventListener('DOMContentLoaded', autoLoadMap);

    // --- High Contrast Mode ---
    const highContrastBtn = document.getElementById('highContrastBtn');
    highContrastBtn.addEventListener('click', function() {
      const enabled = document.body.classList.toggle('high-contrast');
      this.setAttribute('aria-pressed', enabled ? 'true' : 'false');
      localStorage.setItem('dd_map_high_contrast', enabled ? '1' : '0');
    });
    window.addEventListener('DOMContentLoaded', function() {
      if (localStorage.getItem('dd_map_high_contrast') === '1') {
        document.body.classList.add('high-contrast');
        highContrastBtn.setAttribute('aria-pressed', 'true');
      }
    });

    // --- Export as JSON ---
    document.getElementById('exportJsonButton').onclick = function() {
      const data = { gridData, exploredGrid };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'dune_map.json';
      link.click();
    };

    // --- Import from JSON (file input) ---
    document.getElementById('importJsonButton').onclick = function() {
      document.getElementById('importJsonInput').click();
    };
    document.getElementById('importJsonInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const data = JSON.parse(evt.target.result);
          if (data.gridData && data.exploredGrid) {
            gridData = data.gridData;
            exploredGrid = data.exploredGrid;
            rerenderAllCells();
            alert('Map imported!');
          } else {
            alert('Invalid map file.');
          }
        } catch {
          alert('Failed to import map.');
        }
      };
      reader.readAsText(file);
    });

    // --- Import from JSON (drag-and-drop) ---
    document.body.addEventListener('dragover', function(e) {
      e.preventDefault();
    });
    document.body.addEventListener('drop', function(e) {
      e.preventDefault();
      if (e.dataTransfer.files.length) {
        const file = e.dataTransfer.files[0];
        if (file.type === 'application/json' || file.name.endsWith('.json')) {
          const reader = new FileReader();
          reader.onload = function(evt) {
            try {
              const data = JSON.parse(evt.target.result);
              if (data.gridData && data.exploredGrid) {
                gridData = data.gridData;
                exploredGrid = data.exploredGrid;
                rerenderAllCells();
                alert('Map imported!');
              } else {
                alert('Invalid map file.');
              }
            } catch {
              alert('Failed to import map.');
            }
          };
          reader.readAsText(file);
        }
      }
    });

    // --- ARIA roles and keyboard navigation for legend and grid ---
    const legendIcons = document.getElementById('legendIcons');
    legendIcons.addEventListener('keydown', function(e) {
      const items = Array.from(legendIcons.querySelectorAll('.legend-item'));
      const idx = items.indexOf(document.activeElement);
      if (e.key === 'ArrowDown' && idx < items.length - 1) {
        items[idx + 1].focus();
        e.preventDefault();
      } else if (e.key === 'ArrowUp' && idx > 0) {
        items[idx - 1].focus();
        e.preventDefault();
      }
    });

    const gridEl = document.getElementById('gridContainer');
    gridEl.addEventListener('keydown', function(e) {
      const cells = Array.from(gridEl.querySelectorAll('.cell'));
      const idx = cells.indexOf(document.activeElement);
      if (idx === -1) return;
      let nextIdx = idx;
      if (e.key === 'ArrowRight' && (idx + 1) % 9 !== 0) nextIdx++;
      else if (e.key === 'ArrowLeft' && idx % 9 !== 0) nextIdx--;
      else if (e.key === 'ArrowDown' && idx + 9 < 81) nextIdx += 9;
      else if (e.key === 'ArrowUp' && idx - 9 >= 0) nextIdx -= 9;
      if (nextIdx !== idx) {
        cells[nextIdx].focus();
        e.preventDefault();
      }
    });

    // --- Versioning ---
    function getVersionList() {
      const versions = JSON.parse(localStorage.getItem('dd_map_versions') || '[]');
      return versions;
    }
    function saveVersion() {
      const name = prompt('Enter a name for this version:');
      if (!name) return;
      const versions = getVersionList();
      const timestamp = new Date().toISOString();
      versions.push({ name, timestamp, data: { gridData, exploredGrid } });
      localStorage.setItem('dd_map_versions', JSON.stringify(versions));
      alert('Version saved!');
    }
    function loadVersion() {
      const versions = getVersionList();
      if (!versions.length) return alert('No saved versions.');
      let msg = 'Select a version to load:\n';
      versions.forEach((v, i) => {
        msg += `${i + 1}: ${v.name} (${v.timestamp})\n`;
      });
      const idx = parseInt(prompt(msg)) - 1;
      if (isNaN(idx) || idx < 0 || idx >= versions.length) return;
      gridData = versions[idx].data.gridData;
      exploredGrid = versions[idx].data.exploredGrid;
      rerenderAllCells();
      alert('Version loaded!');
    }
    document.getElementById('saveVersionButton').onclick = saveVersion;
    document.getElementById('loadVersionButton').onclick = loadVersion;
    document.getElementById('saveVersionButton').textContent = 'Save Map';
    document.getElementById('loadVersionButton').textContent = 'Load Map';

    // --- Shareable Link ---
    function getShareableLink() {
      const data = { gridData, exploredGrid };
      const encoded = encodeURIComponent(btoa(unescape(encodeURIComponent(JSON.stringify(data)))));
      const url = `${location.origin}${location.pathname}?map=${encoded}`;
      prompt('Copy this link to share your map:', url);
    }
    document.getElementById('shareLinkButton').onclick = getShareableLink;

    // --- Load from shareable link ---
    (function loadFromUrl() {
      const params = new URLSearchParams(location.search);
      if (params.has('map')) {
        try {
          const decoded = decodeURIComponent(params.get('map'));
          const json = JSON.parse(decodeURIComponent(escape(atob(decoded))));
          if (json.gridData && json.exploredGrid) {
            gridData = json.gridData;
            exploredGrid = json.exploredGrid;
            rerenderAllCells();
            alert('Loaded map from link!');
          }
        } catch (e) {
          alert('Failed to load map from link.');
        }
      }
    })();

    // --- Polish: Add tooltips to all controls ---
    ['undoButton','redoButton','exportPngButton','exportJsonButton','importJsonButton','saveVersionButton','loadVersionButton','shareLinkButton','highContrastBtn'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        if (!el.title) el.title = el.textContent;
        el.setAttribute('aria-label', el.textContent);
        el.setAttribute('tabindex', '0');
      }
    });
  </script>
  <div style="margin-top:40px; text-align:center;">
    <a href="https://awakening.wiki/Fremen_with_Benefits" target="_blank" style="text-decoration:none; color:inherit;">
      <img src="fwb.png" alt="Fremen with Benefits" style="max-width:220px; width:100%; border-radius:12px; box-shadow:0 2px 16px #222; margin-bottom:10px;">
      <div style="font-family:Arial,sans-serif; font-size:1.2em; color:#ffe066; font-weight:bold;">
        Created by Fremen with Benefits
      </div>
    </a>
  </div>
  <div style="margin-top:18px; text-align:center;">
    <span style="color:#bbb; font-size:0.95em; background:rgba(30,30,30,0.7); padding:6px 18px; border-radius:8px; display:inline-block;">
      Disclaimer: All assets and watermarks belong to Funcom, Fremen with Benefits and Xtrophic.
    </span>
  </div>
</body>
</html>
```